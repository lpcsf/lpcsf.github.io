<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ONE</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://lpcsf.git.io/"/>
  <updated>2019-11-10T10:48:24.306Z</updated>
  <id>http://lpcsf.git.io/</id>
  
  <author>
    <name>ONE_lpc</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>云计算之Docker 仓库 </title>
    <link href="http://lpcsf.git.io/2019/11/10/%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B9%8BDocker%20%E4%BB%93%E5%BA%93%20/"/>
    <id>http://lpcsf.git.io/2019/11/10/云计算之Docker 仓库 /</id>
    <published>2019-11-10T07:17:32.932Z</published>
    <updated>2019-11-10T10:48:24.306Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker-私有仓库"><a href="#Docker-私有仓库" class="headerlink" title="Docker  私有仓库"></a>Docker  私有仓库</h1><blockquote><p>搭建私有仓库，能使内网的主机加快访问速度，对CI,CD的效率有很大提升。 能有效保护内部代码，防止放到公网泄漏出去。 </p></blockquote><h2 id="一、Docker-registry"><a href="#一、Docker-registry" class="headerlink" title="一、Docker registry"></a>一、Docker registry</h2><a id="more"></a><p> <code>docker-registry</code>是官方提供的工具，可以用于构建私有的镜像仓库。 </p><h3 id="1-1-安装运行-Docker-registry"><a href="#1-1-安装运行-Docker-registry" class="headerlink" title="1.1 安装运行 Docker-registry"></a>1.1 安装运行 Docker-registry</h3><p><strong>docker01上创建私有仓库</strong></p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@docker01 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># docker run -d -p 5000:5000 --restart=always --name registry -v /opt/myregistry:/var/lib/registry  registry</span></code></pre><p><strong>docker02 上传到私有仓库</strong></p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 查看镜像</span><span class="token punctuation">[</span>root@docker02 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># docker images </span>REPOSITORY          TAG            IMAGE ID                CREATED                 SIZEbusybox             latest         d8233ab899d4            8 months ago            1.2MB<span class="token comment" spellcheck="true"># 给镜像打标签</span>需要传到我们的私有仓库，可以用IP或域名<span class="token punctuation">[</span>root@docker02 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># docker tag busybox:latest 10.0.0.10:5000/busybox:latest</span><span class="token comment" spellcheck="true"># 上次镜像</span><span class="token punctuation">[</span>root@docker02 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># docker pull 10.0.0.10:5000/busybox:latest </span><span class="token comment" spellcheck="true"># 第一次会遇到报错</span><span class="token comment" spellcheck="true"># 因为 Docker 默认不允许非 HTTPS 方式推送镜像。我们可以通过 Docker 的配置选项来取消这个限制</span>The push refers to repository <span class="token punctuation">[</span>10.0.0.10:5000/busybox:latest<span class="token punctuation">]</span>Get https://10.0.0.10:5000/v2/: http: server gave HTTP response to HTTPS client<span class="token comment" spellcheck="true"># 解决方法/添加信任私有仓库</span><span class="token punctuation">[</span>root@docker02 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># vim  /etc/docker/daemon.json</span><span class="token punctuation">{</span>  <span class="token string">"insecure-registries"</span><span class="token keyword">:</span> <span class="token punctuation">[</span><span class="token string">"10.0.0.10:5000"</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">[</span>root@docker02 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># systemctl restart docker</span><span class="token comment" spellcheck="true"># 再次上传</span><span class="token punctuation">[</span>root@docker02 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># docker push 10.0.0.10:5000/busybox   </span>The push refers to repository <span class="token punctuation">[</span>10.0.0.10:5000/busybox<span class="token punctuation">]</span>78cd8c87ab42: Pushed 60ab55d3379d: Pushed latest: digest: sha256:4415a904b1aca178c2450fd54928ab362825e863c0ad5452fd020e92f7a6a47e size: 527</code></pre><p><strong>查看镜像仓库镜像</strong> </p><p>使用浏览器访问： <a href="http://10.0.0.10:5000/v2/_catalog" target="_blank" rel="noopener">http://10.0.0.10:5000/v2/_catalog</a></p><p>由于我们将私有仓库做了持久化，所以可以在docker01 上找到上传的镜像</p><p><img src="http://tu.bossx.club/blog/20191110/Gr2daQaOoTwE.png" alt="mark"></p><h3 id="1-2-带basic认证的registry"><a href="#1-2-带basic认证的registry" class="headerlink" title="1.2 带basic认证的registry"></a>1.2 带basic认证的registry</h3><p><strong>docker01</strong> </p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 删除之前的私有仓库</span>docker <span class="token function">rm</span> -f registry<span class="token comment" spellcheck="true"># </span>yum <span class="token function">install</span> httpd-tools -y<span class="token comment" spellcheck="true"># 创建目录</span><span class="token function">mkdir</span> /opt/registry-var/auth/ -p<span class="token comment" spellcheck="true"># 生成密码文件</span>htpasswd  -Bbn onelpc 123456  <span class="token operator">>></span> /opt/registry-var/auth/htpasswd<span class="token comment" spellcheck="true">#启动容器 </span>docker run -d -p 5000:5000 --restart<span class="token operator">=</span>always -v /opt/registry-var/auth/:/auth/ -v /opt/myregistry:/var/lib/registry -e <span class="token string">"REGISTRY_AUTH=htpasswd"</span> -e <span class="token string">"REGISTRY_AUTH_HTPASSWD_REALM=Registry Realm"</span> -e  <span class="token string">"REGISTRY_AUTH_HTPASSWD_PATH=/auth/htpasswd"</span> registry </code></pre><p><strong>docker 02</strong> </p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 再次从私有仓库下载镜像</span><span class="token punctuation">[</span>root@docker02 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># docker pull 10.0.0.11:5000/busybox</span>Using default tag: latestError response from daemon: Get http://10.0.0.11:5000/v2/busybox/manifests/latest: no basic auth credentials-- 此时报错是没有登录<span class="token comment" spellcheck="true"># 登录私有仓库</span><span class="token punctuation">[</span>root@docker02 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># docker login 10.0.0.11:5000</span>Username: oldboyPassword: WARNING<span class="token operator">!</span> Your password will be stored unencrypted <span class="token keyword">in</span> /root/.docker/config.json.Configure a credential helper to remove this warning. Seehttps://docs.docker.com/engine/reference/commandline/login/<span class="token comment" spellcheck="true">#credentials-store</span>Login Succeeded<span class="token comment" spellcheck="true"># 再次下载镜像</span><span class="token punctuation">[</span>root@docker01 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># docker pull 10.0.0.11:5000/busybox</span>Using default tag: latestlatest: Pulling from busyboxDigest: sha256:4415a904b1aca178c2450fd54928ab362825e863c0ad5452fd020e92f7a6a47eStatus: Image is up to <span class="token function">date</span> <span class="token keyword">for</span> 10.0.0.11:5000/busybox:latest10.0.0.11:5000/busybox:latest</code></pre><h2 id="二、docker-企业级私有仓库-Harbor"><a href="#二、docker-企业级私有仓库-Harbor" class="headerlink" title="二、docker 企业级私有仓库 Harbor"></a>二、docker 企业级私有仓库 Harbor</h2><h3 id="2-1-Harbor-概述"><a href="#2-1-Harbor-概述" class="headerlink" title="2.1 Harbor 概述"></a>2.1 Harbor 概述</h3><p>Habor是由VMWare公司开源的容器镜像仓库。事实上，Habor是在Docker Registry上进行了相应的<br>企业级扩展，从而获得了更加广泛的应用，这些新的企业级特性包括：管理用户界面，基于角色的访<br>问控制 ，AD/LDAP集成以及审计日志等，足以满足基本企业需求。<br>官方地址：<a href="https://vmware.github.io/harbor/cn/" target="_blank" rel="noopener">https://vmware.github.io/harbor/cn/</a></p><p> <img src="https://s1.51cto.com/images/blog/201811/27/7aed213fd4a040a229cb7fd0ef404bee.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt="img"> </p><h3 id="2-2-Harbor-优势"><a href="#2-2-Harbor-优势" class="headerlink" title="2.2 Harbor 优势"></a>2.2 Harbor 优势</h3><ul><li><p><strong>友好的web界面</strong></p></li><li><p><strong>基于角色访问控制（RBAC）</strong></p><p>在企业中，通常有不同的开发团队负责不同的项目，镜像像代码一样，每个人角色不同需求也不同，因此就需要访问权限控制，根据角色分配相应的权限。 </p></li><li><p><strong>镜像复制</strong></p><p>可以将仓库中的镜像同步到远程的Harbor，类似于MySQL主从同步功能。</p></li><li><p><strong>LDAP</strong></p><p>Harbor支持LDAP认证，可以很轻易接入已有的LDAP。</p></li><li><p><strong>镜像删除和空间回收</strong></p><p>Harbor支持在Web删除镜像，回收无用的镜像，释放磁盘空间。</p></li><li><p><strong>图形页面管理</strong></p><p>用户很方面搜索镜像及项目管理。</p></li><li><p><strong>审计</strong></p><p>对仓库的所有操作都有记录。</p></li><li><p><strong>REST API</strong></p><p>完整的API，方便与外部集成。</p></li></ul><h3 id="2-3-搭建harbor-仓库"><a href="#2-3-搭建harbor-仓库" class="headerlink" title="2.3 搭建harbor 仓库"></a>2.3 搭建harbor 仓库</h3><blockquote><p>Harbor离线安装包下载地址：<a href="https://github.com/goharbor/harbor" target="_blank" rel="noopener">https://github.com/goharbor/harbor</a> </p></blockquote><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 下载 docker-compose (需要epel源)</span>yum <span class="token function">install</span> docker-compose <span class="token comment" spellcheck="true"># 下载harbor-offline</span><span class="token comment" spellcheck="true"># 上传到/opt，并且解压</span><span class="token function">tar</span> xf harbor-offline-installer-v1.9.2.tgz<span class="token function">cd</span> harbor<span class="token comment" spellcheck="true"># 修改harbor.cfg配置文件</span>hostname<span class="token operator">=</span> 10.0.0.12               <span class="token comment" spellcheck="true"># 仓库IP地址</span>harbor_admin_password<span class="token operator">=</span>123456    <span class="token comment" spellcheck="true"># 默认登录密码</span><span class="token comment" spellcheck="true"># 执行install.sh</span>./install.sh </code></pre><p>一下提示说明安装完成</p><p><img src="http://tu.bossx.club/blog/20191110/dtmOq5S8Oacb.png" alt="安装完成"></p><p>访问 10.0.0.12</p><p><img src="http://tu.bossx.club/blog/20191110/5NbIxHX9KVPD.png" alt="mark"></p><p>由于没有配置HTTPS ，其他主机需要配置htpp镜像仓库可信任，才可以进行推送与拉取镜像</p><h3 id="2-4-harbor配置https"><a href="#2-4-harbor配置https" class="headerlink" title="2.4 harbor配置https"></a>2.4 harbor配置https</h3><blockquote><p>会将之前的harbor仓库删除，重新生成</p></blockquote><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 上传https证书</span><span class="token comment" spellcheck="true"># 修改配置文件harbor.cfg</span><span class="token function">hostname</span> <span class="token operator">=</span> onelpc.com         <span class="token comment" spellcheck="true"># 域名</span>ui_url_protocol <span class="token operator">=</span> https        <span class="token comment" spellcheck="true"># 使用的协议</span>ssl_cert <span class="token operator">=</span> /opt/certs/Nginx/1_blog.qstack.com.cn_bundle.crt    <span class="token comment" spellcheck="true">#https证书路径</span>ssl_cert_key <span class="token operator">=</span> /opt/certs/Nginx/2_blog.qstack.com.cn.key    <span class="token comment" spellcheck="true">#https证书路径</span><span class="token comment" spellcheck="true">#修改脚本文件注释这一行加快执行速度(由于之前到过镜像)</span><span class="token punctuation">[</span>root@docker02 harbor<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># vim install.sh </span><span class="token comment" spellcheck="true">#       docker load -i ./harbor*.tar.gz</span><span class="token comment" spellcheck="true">#执行脚本安装harbor</span><span class="token punctuation">[</span>root@docker02 harbor<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># ./install.sh</span></code></pre><h3 id="2-5-批量导入镜像脚本"><a href="#2-5-批量导入镜像脚本" class="headerlink" title="2.5 批量导入镜像脚本"></a>2.5 批量导入镜像脚本</h3><blockquote><p>之前在docker01 主机上搭建的<code>docker-registry</code>仓库，将原仓库中的镜像导入到harbor仓库中</p></blockquote><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#docker01上登录</span><span class="token punctuation">[</span>root@docker01 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># docker login blog.qstack.com.cn</span>Username: adminPassword: 123456<span class="token comment" spellcheck="true">#执行脚本</span><span class="token punctuation">[</span>root@docker01 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># sh daoru.sh</span><span class="token comment" spellcheck="true"># 脚本内容如下</span><span class="token punctuation">[</span>root@docker01 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># cat /server/scripts/daoru.sh </span><span class="token comment" spellcheck="true">#!/bin/bash</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token variable"><span class="token variable">`</span><span class="token function">ls</span> /opt/myregistry/docker/registry/v2/repositories/<span class="token variable">`</span></span><span class="token keyword">do</span>   image<span class="token operator">=</span><span class="token variable">$i</span>   <span class="token keyword">echo</span> 镜像名称:<span class="token variable">$image</span>   <span class="token keyword">for</span> <span class="token function">v</span> <span class="token keyword">in</span> <span class="token variable"><span class="token variable">`</span><span class="token function">ls</span> /opt/myregistry/docker/registry/v2/repositories/nginx/_manifests/tags/<span class="token variable">`</span></span>   <span class="token keyword">do</span>      docker pull 10.0.0.12:5000/<span class="token variable">$image</span><span class="token keyword">:</span><span class="token variable">$v</span>      docker tag  10.0.0.12:5000/<span class="token variable">$image</span><span class="token keyword">:</span><span class="token variable">$v</span> blog.qstack.com.cn/library/<span class="token variable">$image</span><span class="token keyword">:</span><span class="token variable">$v</span>      docker push blog.qstack.com.cn/library/<span class="token variable">$image</span><span class="token keyword">:</span><span class="token variable">$v</span>   <span class="token keyword">done</span><span class="token keyword">echo</span> <span class="token string">"-------------------------------------"</span><span class="token keyword">done</span></code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Docker-私有仓库&quot;&gt;&lt;a href=&quot;#Docker-私有仓库&quot; class=&quot;headerlink&quot; title=&quot;Docker  私有仓库&quot;&gt;&lt;/a&gt;Docker  私有仓库&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;搭建私有仓库，能使内网的主机加快访问速度，对CI,CD的效率有很大提升。 能有效保护内部代码，防止放到公网泄漏出去。 &lt;/p&gt;
&lt;/blockquote&gt;&lt;h2 id=&quot;一、Docker-registry&quot;&gt;&lt;a href=&quot;#一、Docker-registry&quot; class=&quot;headerlink&quot; title=&quot;一、Docker registry&quot;&gt;&lt;/a&gt;一、Docker registry&lt;/h2&gt;
    
    </summary>
    
    
      <category term="Docker" scheme="http://lpcsf.git.io/categories/Docker/"/>
    
    
      <category term="云计算" scheme="http://lpcsf.git.io/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="DOCKER" scheme="http://lpcsf.git.io/tags/DOCKER/"/>
    
  </entry>
  
  <entry>
    <title>云计算之Docker 网络</title>
    <link href="http://lpcsf.git.io/2019/11/10/%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B9%8BDocker%20%E7%BD%91%E7%BB%9C/"/>
    <id>http://lpcsf.git.io/2019/11/10/云计算之Docker 网络/</id>
    <published>2019-11-10T07:03:53.482Z</published>
    <updated>2019-11-10T10:41:08.886Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker-网络"><a href="#Docker-网络" class="headerlink" title="Docker  网络"></a>Docker  网络</h1><h2 id="一、Docker-网络模式"><a href="#一、Docker-网络模式" class="headerlink" title="一、Docker 网络模式"></a>一、Docker 网络模式</h2><ul><li><p>host 模式</p><p>容器和宿主机共享 network namespace</p></li><li><p>container 模式</p><p>容器和另外一个容器共享 Network namespace</p></li><li><p>none 模式: </p><p>该模式关闭了容器的网络功能</p></li><li><p>bridge 模式</p><p>默认模式，该模式会为每一个容器分配IP，并将容器连接到一个docker 0的虚拟网桥上</p></li></ul><a id="more"></a><h3 id="1-1-bridge-模式"><a href="#1-1-bridge-模式" class="headerlink" title="1.1 bridge 模式"></a>1.1 bridge 模式</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>当Docker进程启动时，会在主机上创建一个名为docker0的虚拟网桥。</p><p>此主机上启动<em>Docker容器会连接到这个虚拟网桥上，所以有*</em>默认地址172.17.0.0/16**的地址。</p><p>从docker0子网中分配一个IP给容器使用，并设置docker0的IP地址为容器的默认网关。</p><p>在主机上创建一对虚拟网卡veth pair设备，Docker将veth pair设备的一端放在新创建的容器中，并命名为eth0（</p><p>另一端放在主机中，以vethxxx这样类似的名字命名，并将这个网络设备加入到docker0网桥中。可以通过brctl show命令查看。</p><h4 id="bridge-示意图"><a href="#bridge-示意图" class="headerlink" title="bridge 示意图"></a>bridge 示意图</h4><p> <img src="http://tu.bossx.club/blog/20191110/VqOPjwmm379I.png" alt="mark"></p><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@docker01 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># docker run -it --network=bridge busybox</span>/ <span class="token comment" spellcheck="true"># hostname </span>5b49bbaecb7e/ <span class="token comment" spellcheck="true"># ifconfig </span>eth0      Link encap:Ethernet  HWaddr 02:42:AC:11:00:02            inet addr:172.17.0.2  Bcast:172.17.255.255  Mask:255.255.0.0          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1          RX packets:7 errors:0 dropped:0 overruns:0 frame:0          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0          collisions:0 txqueuelen:0           RX bytes:586 <span class="token punctuation">(</span>586.0 B<span class="token punctuation">)</span>  TX bytes:0 <span class="token punctuation">(</span>0.0 B<span class="token punctuation">)</span>lo        Link encap:Local Loopback            inet addr:127.0.0.1  Mask:255.0.0.0          UP LOOPBACK RUNNING  MTU:65536  Metric:1          RX packets:0 errors:0 dropped:0 overruns:0 frame:0          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0          collisions:0 txqueuelen:1000           RX bytes:0 <span class="token punctuation">(</span>0.0 B<span class="token punctuation">)</span>  TX bytes:0 <span class="token punctuation">(</span>0.0 B<span class="token punctuation">)</span></code></pre><h3 id="1-2-host-模式"><a href="#1-2-host-模式" class="headerlink" title="1.2 host 模式"></a>1.2 host 模式</h3><h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><p>使用<code>host</code>网络模式，  容器将不会虚拟出自己的网卡，配置自己的IP等，而是<strong>使用宿主机的IP和端口</strong>。</p><p><strong>容器的其他方面，如文件系统、进程列表等还是和宿主机隔离的</strong>。 </p><p>host 模式不需要做网络地址转换(NAT)，并且不会为每个端口创建”userlad-proxy”，所以它的<strong>性能是最高</strong>的。</p><h4 id="Host-模式示意图"><a href="#Host-模式示意图" class="headerlink" title="Host 模式示意图"></a>Host 模式示意图</h4><p><img src="http://tu.bossx.club/blog/20191110/1Hf7Aecesec0.png" alt="host"></p><h4 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h4><blockquote><p>公用宿主机，主机名与IP地址都与宿主机公用</p></blockquote><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@docker01 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># docker run -it --network=host busybox</span>/ <span class="token comment" spellcheck="true"># hostname </span>docker01/ <span class="token comment" spellcheck="true"># ifconfig eth0</span>eth0      Link encap:Ethernet  HWaddr 00:0C:29:3A:CC:0A            inet addr:10.0.0.11  Bcast:10.0.0.255  Mask:255.255.255.0          inet6 addr: fe80::20c:29ff:fe3a:cc0a/64 Scope:Link          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1          RX packets:523747 errors:0 dropped:0 overruns:0 frame:0          TX packets:147805 errors:0 dropped:0 overruns:0 carrier:0          collisions:0 txqueuelen:1000           RX bytes:746408332 <span class="token punctuation">(</span>711.8 MiB<span class="token punctuation">)</span>  TX bytes:18872001 <span class="token punctuation">(</span>17.9 MiB<span class="token punctuation">)</span></code></pre><h3 id="1-3-container-模式"><a href="#1-3-container-模式" class="headerlink" title="1.3 container 模式"></a>1.3 container 模式</h3><h4 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h4><p>这个模式指定<strong>新创建的容器和已经存在的一个容器共享一个 Network Namespace</strong>，而不是和宿主机共享。</p><p><strong>新创建的容器不会创建自己的网卡，配置自己的 IP，而是和一个指定的容器共享 IP、端口范围</strong>等。</p><p>同样，<strong>两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的</strong>。</p><p>两个容器的进程可以通过 lo 网卡设备通信。</p><h4 id="container-模式示意图"><a href="#container-模式示意图" class="headerlink" title="container 模式示意图"></a>container 模式示意图</h4><p><img src="http://tu.bossx.club/blog/20191110/SkMS4OStxpRT.png" alt="container">)) </p><h4 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h4><pre class=" language-shell"><code class="language-shell">[root@docker01 ~]# docker run -it --network container:5b49bbaecb7e  busybox/ # hostname 5b49bbaecb7e/ # ifconfig eth0      Link encap:Ethernet  HWaddr 02:42:AC:11:00:02            inet addr:172.17.0.2  Bcast:172.17.255.255  Mask:255.255.0.0          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1          RX packets:8 errors:0 dropped:0 overruns:0 frame:0          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0          collisions:0 txqueuelen:0           RX bytes:656 (656.0 B)  TX bytes:0 (0.0 B)lo        Link encap:Local Loopback            inet addr:127.0.0.1  Mask:255.0.0.0          UP LOOPBACK RUNNING  MTU:65536  Metric:1          RX packets:0 errors:0 dropped:0 overruns:0 frame:0          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0          collisions:0 txqueuelen:1000           RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)</code></pre><h3 id="1-4-node-模式"><a href="#1-4-node-模式" class="headerlink" title="1.4 node 模式"></a>1.4 node 模式</h3><h4 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h4><p> 使用none模式，Docker容器拥有自己的Network Namespace，但是，<strong>并不为Docker容器进行任何网络配置</strong>。 </p><p> 也就是说，这个Docker容器没有网卡、IP、路由等信息，只有lo 网络接口。 </p><h4 id="none-示意图"><a href="#none-示意图" class="headerlink" title="none 示意图"></a>none 示意图</h4><p><img src="http://tu.bossx.club/blog/20191110/Xbrhp8dphW8E.png" alt="node">) ) </p><h4 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h4><pre class=" language-shell"><code class="language-shell">[root@docker01 ~]# docker run -it --network none busybox/ # ifconfig lo        Link encap:Local Loopback            inet addr:127.0.0.1  Mask:255.0.0.0          UP LOOPBACK RUNNING  MTU:65536  Metric:1          RX packets:0 errors:0 dropped:0 overruns:0 frame:0          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0          collisions:0 txqueuelen:1000           RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)</code></pre><h3 id="1-5-Docker-网络相关命令"><a href="#1-5-Docker-网络相关命令" class="headerlink" title="1.5 Docker 网络相关命令"></a>1.5 Docker 网络相关命令</h3><table><thead><tr><th>docker 命令</th><th>说明</th></tr></thead><tbody><tr><td>docker network connect</td><td>将容器连接到网络</td></tr><tr><td>docker network create</td><td>创建一个网络</td></tr><tr><td>docker network disconnect</td><td>将容器从网络断开</td></tr><tr><td>docker network inspect</td><td>查看网络的详细信息</td></tr><tr><td>docker network ls</td><td>查看网络列表</td></tr><tr><td>docker network prune</td><td>删除所有未使用的网络</td></tr><tr><td>docker network rm</td><td>删除网络</td></tr></tbody></table><h2 id="二、Docker-跨主机容器之间的通讯macvlan"><a href="#二、Docker-跨主机容器之间的通讯macvlan" class="headerlink" title="二、Docker 跨主机容器之间的通讯macvlan"></a>二、Docker 跨主机容器之间的通讯macvlan</h2><h3 id="2-1-macvlan-介绍"><a href="#2-1-macvlan-介绍" class="headerlink" title="2.1 macvlan 介绍"></a>2.1 macvlan 介绍</h3><p>macvlan 本身是 linux kernel 模块，其功能是允许在同一个物理网卡上配置多个 MAC 地址，</p><p>即多个 interface，每个 interface 可以配置自己的 IP。</p><p>macvlan 本质上是一种网卡虚拟化技术</p><h3 id="2-2-macvlan网络-创建"><a href="#2-2-macvlan网络-创建" class="headerlink" title="2.2 macvlan网络 创建"></a>2.2 macvlan网络 创建</h3><pre class=" language-shell"><code class="language-shell">[root@docker01 ~]# docker network create --driver macvlan --subnet 10.0.0.0/24 --gateway 10.0.0.254 -o parent=eth0 macvlan_1参数说明--driver          使用的网络类型--subnet          使用的网段/子网范围--gateway         网段地址-o parent=eth0  基于eth0进行的桥接/流量将在docker主机上的实际通过的接口macvlan_1        创建网络的名称    </code></pre><p>查看创建网络</p><pre class=" language-shell"><code class="language-shell">[root@docker01 ~]# docker network lsNETWORK ID          NAME                DRIVER              SCOPEb8aa27b430c9        bridge              bridge              local418c982a7562        host                host                localb1627a2e64ff        macvlan_1           macvlan             local   ##创建的macvlan网络7adeb86e280f        none                null                local</code></pre><h3 id="2-3-macvlan网络-测试"><a href="#2-3-macvlan网络-测试" class="headerlink" title="2.3 macvlan网络 测试"></a>2.3 macvlan网络 测试</h3><p><strong>环境说明</strong></p><p>​    使用镜像 centos:6.9    </p><p>​    docker01 主机：10.0.0.11    </p><p>​    docker02 主机：10.0.0.12</p><p><strong>1) 开启网卡的混杂模式</strong></p><pre class=" language-shell"><code class="language-shell">ip link set eth0 promisc on</code></pre><p><strong>2) 创建网络</strong> </p><p> docker01 与docker02 同时操作</p><pre class=" language-shell"><code class="language-shell">docker network create --driver macvlan --subnet 10.0.0.0/24 --gateway 10.0.0.254 -o parent=eth0 macvlan_1</code></pre><p><strong>3) 创建容器</strong></p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@docker01 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># docker run -it --network macvlan_1  --ip=10.0.0.100 busybox</span><span class="token punctuation">[</span>root@docker02 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># docker run -it --network macvlan_1  --ip=10.0.0.200 busybox</span></code></pre><p><strong>4) 访问测试</strong></p><p>#docker01 主机</p><pre class=" language-shell"><code class="language-shell">-- 连接docker02 主机上的容器/ # ping 10.0.0.200PING 10.0.0.200 (10.0.0.200): 56 data bytes64 bytes from 10.0.0.200: seq=0 ttl=64 time=0.324 ms64 bytes from 10.0.0.200: seq=1 ttl=64 time=0.437 ms-- 连接 docker02 主机/ # ping -w 3 10.0.0.11PING 10.0.0.11 (10.0.0.11): 56 data bytes--- 10.0.0.11 ping statistics ---4 packets transmitted, 0 packets received, 100% packet loss-- 连接docker01 主机/ # ping  10.0.0.12PING 10.0.0.12 (10.0.0.12): 56 data bytes64 bytes from 10.0.0.12: seq=1 ttl=64 time=0.662 ms</code></pre><p><strong>5) DHCP 模式</strong></p><blockquote><p>问题：每个容器都会从<code>1</code>开始分配</p></blockquote><pre class=" language-shell"><code class="language-shell">[root@docker01 ~]# docker run -it --network macvlan_1 centos:6.9[root@b0031b3570ba /]# ifconfig eth0      Link encap:Ethernet  HWaddr 02:42:0A:00:00:01            inet addr:10.0.0.1  Bcast:10.0.0.255  Mask:255.255.255.0          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1          RX packets:0 errors:0 dropped:0 overruns:0 frame:0          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0          collisions:0 txqueuelen:0           RX bytes:0 (0.0 b)  TX bytes:0 (0.0 b)[root@docker02 ~]# docker run -it --network macvlan_1 centos:6.9 [root@648805d9dea4 /]# ifconfig eth0      Link encap:Ethernet  HWaddr 02:42:0A:00:00:01            inet addr:10.0.0.1  Bcast:10.0.0.255  Mask:255.255.255.0          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1          RX packets:0 errors:0 dropped:0 overruns:0 frame:0          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0          collisions:0 txqueuelen:0           RX bytes:0 (0.0 b)  TX bytes:0 (0.0 b)</code></pre><h3 id="2-4-macvlan-网络的缺点"><a href="#2-4-macvlan-网络的缺点" class="headerlink" title="2.4 macvlan 网络的缺点"></a>2.4 macvlan 网络的缺点</h3><ul><li>需要手动指令IP地址，容易出现IP地址冲突问题</li><li>使用macvlan网络的容器无法连接宿主机</li></ul><h2 id="三、Dcoker跨主机容器通信之overlay"><a href="#三、Dcoker跨主机容器通信之overlay" class="headerlink" title="三、Dcoker跨主机容器通信之overlay"></a>三、Dcoker跨主机容器通信之overlay</h2><h3 id="3-1-overlay-介绍"><a href="#3-1-overlay-介绍" class="headerlink" title="3.1 overlay 介绍"></a>3.1 overlay 介绍</h3><p> overlay模式是多个Docker主机之间的分布式网络解决方案。</p><p>该网络位于特定于主机的网络之上，允许连接到它的容器（包括群集服务容器）安全地进行通信。</p><p>Docker透明地处理每个数据包与Docker守护程序主机和正确的目标容器之间正确的的路由。 </p><p><img src="http://tu.bossx.club/blog/20191109/rJTXbAU6szE9.png?imageslim" alt="overlay"></p><h3 id="3-2-overlay-网络使用条件"><a href="#3-2-overlay-网络使用条件" class="headerlink" title="3.2 overlay 网络使用条件"></a>3.2 overlay 网络使用条件</h3><ul><li>正常工作的key-value 存储服务，比如 consul、etcd、zookeeper 等</li><li>可以访问到 key-value 服务的主机集群</li><li>集群中的每台机器的hostname都是唯一的</li></ul><h3 id="3-3-overlay-网络模拟"><a href="#3-3-overlay-网络模拟" class="headerlink" title="3.3 overlay 网络模拟"></a>3.3 overlay 网络模拟</h3><h4 id="环境说明"><a href="#环境说明" class="headerlink" title="环境说明"></a>环境说明</h4><p><strong>主机</strong></p><p>docker-network 10.0.0.10</p><p>docker01 10.0.0.11</p><p>docker02 10.0.0.12</p><p><strong>docker 版本</strong>： Docker version 19.03.4</p><h4 id="启动consul"><a href="#启动consul" class="headerlink" title="启动consul"></a>启动consul</h4><blockquote><p>这里直接使用最简单的<code>docker</code>方式启动</p></blockquote><p>创建一个consul 容器</p><pre class=" language-shell"><code class="language-shell">[root@consul ~]# docker run -d -p 8500:8500 -h consul --name consul progrium/consul -server -bootstrap[root@consul ~]# netstat -lntup|grep 8500tcp6       0      0 :::8500                 :::*                    LISTEN      9628/docker-proxy  </code></pre><p>容器创建成功后，会启动一个8500端口</p><p>我们通过此端口可以访问consul的web管理界面</p><p><img src="http://tu.bossx.club/blog/20191109/DDMr1kYV1yH2.png?imageslim" alt="consul"></p><h4 id="修改docker-配置文件"><a href="#修改docker-配置文件" class="headerlink" title="修改docker 配置文件"></a>修改docker 配置文件</h4><blockquote><p>–cluster-store 指定 consul 的地址。<br>–cluster-advertise 告知 consul 自己的连接地址。 </p></blockquote><p>docker01 </p><pre class=" language-shell"><code class="language-shell">[root@docker01 ~]# vim /etc/docker/daemon.json{  "hosts":["tcp://0.0.0.0:2376","unix:///var/run/docker.sock"],  "cluster-store": "consul://10.0.0.10:8500",  "cluster-advertise": "10.0.0.11:2376"}[root@docker01 ~]#  vim /usr/lib/systemd/system/docker.serviceExecStart=/usr/bin/dockerd --containerd=/run/containerd/containerd.sock   [root@docker01 ~]# systemctl daemon-reload [root@docker01 ~]# systemctl restart docker</code></pre><p>docker02 </p><pre class=" language-shell"><code class="language-shell">[root@docker02 ~]# vim /etc/docker/daemon.json{  "hosts":["tcp://0.0.0.0:2376","unix:///var/run/docker.sock"],  "cluster-store": "consul://10.0.0.10:8500",  "cluster-advertise": "10.0.0.12:2376"}[root@docker02 ~]#  vim /usr/lib/systemd/system/docker.serviceExecStart=/usr/bin/dockerd --containerd=/run/containerd/containerd.sock   [root@docker02 ~]# systemctl daemon-reload [root@docker02 ~]# systemctl restart docker</code></pre><p>此时 docker01 与docker02 将自动注册到consul 数据库中</p><p><img src="http://tu.bossx.club/blog/20191109/FXo0PQfe1GHD.png" alt></p><h4 id="创建-overlay-网络"><a href="#创建-overlay-网络" class="headerlink" title="创建 overlay 网络"></a>创建 overlay 网络</h4><p>docker01 </p><pre class=" language-shell"><code class="language-shell"> [root@docker01 ~]# docker network create -d overlay --subnet 172.16.2.0/24 --gateway 172.16.2.254  ol1 [root@docker01 ~]# docker network ls NETWORK ID          NAME                DRIVER              SCOPE7cf8a5332f43        ol1                 overlay             global</code></pre><h4 id="测试网络"><a href="#测试网络" class="headerlink" title="测试网络"></a>测试网络</h4><p>创建容器查看网络</p><blockquote><p>这里需要注意，在overlay网络中，集群中的容器名称必须唯一</p></blockquote><pre class=" language-shell"><code class="language-shell">[root@docker01 ~]# docker run -it --network ol1 --name test01  busybox:latest/ # ifconfig eth0      Link encap:Ethernet  HWaddr 02:42:AC:10:02:01            inet addr:172.16.2.1  Bcast:172.16.2.255  Mask:255.255.255.0eth1      Link encap:Ethernet  HWaddr 02:42:AC:12:00:02            inet addr:172.18.0.2  Bcast:172.18.255.255  Mask:255.255.0.0[root@docker02 ~]# docker run -it --network ol1 --name test02  busybox:latest/ # ifconfig eth0      Link encap:Ethernet  HWaddr 02:42:AC:10:02:02            inet addr:172.16.2.2  Bcast:172.16.2.255  Mask:255.255.255.0eth1      Link encap:Ethernet  HWaddr 02:42:AC:12:00:02            inet addr:172.18.0.2  Bcast:172.18.255.255  Mask:255.255.0.0</code></pre><p>连接测试</p><pre class=" language-shell"><code class="language-shell">[root@docker02 ~]# docker run -it --network ol1 --name test02  busybox:latest/ # ping 172.16.2.1PING 172.16.2.1 (172.16.2.1): 56 data bytes64 bytes from 172.16.2.1: seq=0 ttl=64 time=0.399 ms64 bytes from 172.16.2.1: seq=1 ttl=64 time=0.373 ms/ # ping test01PING test01 (172.16.2.1): 56 data bytes64 bytes from 172.16.2.1: seq=0 ttl=64 time=0.317 ms64 bytes from 172.16.2.1: seq=1 ttl=64 time=0.478 ms/ # ping 223.5.5.5PING 223.5.5.5 (223.5.5.5): 56 data bytes64 bytes from 223.5.5.5: seq=0 ttl=127 time=6.389 ms64 bytes from 223.5.5.5: seq=1 ttl=127 time=11.280 ms/ # ping 10.0.0.11PING 10.0.0.11 (10.0.0.11): 56 data bytes64 bytes from 10.0.0.11: seq=0 ttl=63 time=0.455 ms/ # ping 10.0.0.10PING 10.0.0.10 (10.0.0.10): 56 data bytes64 bytes from 10.0.0.10: seq=0 ttl=63 time=0.342 ms</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Docker-网络&quot;&gt;&lt;a href=&quot;#Docker-网络&quot; class=&quot;headerlink&quot; title=&quot;Docker  网络&quot;&gt;&lt;/a&gt;Docker  网络&lt;/h1&gt;&lt;h2 id=&quot;一、Docker-网络模式&quot;&gt;&lt;a href=&quot;#一、Docker-网络模式&quot; class=&quot;headerlink&quot; title=&quot;一、Docker 网络模式&quot;&gt;&lt;/a&gt;一、Docker 网络模式&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;host 模式&lt;/p&gt;
&lt;p&gt;容器和宿主机共享 network namespace&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;container 模式&lt;/p&gt;
&lt;p&gt;容器和另外一个容器共享 Network namespace&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;none 模式: &lt;/p&gt;
&lt;p&gt;该模式关闭了容器的网络功能&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;bridge 模式&lt;/p&gt;
&lt;p&gt;默认模式，该模式会为每一个容器分配IP，并将容器连接到一个docker 0的虚拟网桥上&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Docker" scheme="http://lpcsf.git.io/categories/Docker/"/>
    
    
      <category term="云计算" scheme="http://lpcsf.git.io/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="DOCKER" scheme="http://lpcsf.git.io/tags/DOCKER/"/>
    
  </entry>
  
  <entry>
    <title>云计算之Docker 基础</title>
    <link href="http://lpcsf.git.io/2019/11/03/%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B9%8BDocker%20%E5%9F%BA%E7%A1%80/"/>
    <id>http://lpcsf.git.io/2019/11/03/云计算之Docker 基础/</id>
    <published>2019-11-03T08:28:31.277Z</published>
    <updated>2019-11-10T10:40:57.947Z</updated>
    
    <content type="html"><![CDATA[<h1 id="云计算之Docker-基础"><a href="#云计算之Docker-基础" class="headerlink" title="云计算之Docker 基础"></a>云计算之Docker 基础</h1><h2 id="1、容器的定义"><a href="#1、容器的定义" class="headerlink" title="1、容器的定义"></a>1、容器的定义</h2><ul><li>容器就是在隔离的环境运行的一个进程，如果进程停止，容器就会退出；</li><li>隔离的环境拥有自己的系统文件，ip 地址，主机名等；</li><li>相比虚拟化，容器更加轻便、快捷高效、快速回滚，共用宿主机内核；</li><li>容器是linux内核独有的技术;</li><li>目前最常用的容器 Docker（基于 lxc 重构）。</li></ul><a id="more"></a><h2 id="2、Docker的安装"><a href="#2、Docker的安装" class="headerlink" title="2、Docker的安装"></a>2、Docker的安装</h2><pre class=" language-shell"><code class="language-shell">curl -o /etc/yum.repos.d/docker-ce.repo https://mirrors.ustc.edu.cn/docker-ce/linux/centos/docker-ce.reposed -i 's#download.docker.com#mirrors.tuna.tsinghua.edu.cn/docker-ce#g' /etc/yum.repos.d/docker-ce.repoyum install docker-ce-18.09.9 -y</code></pre><h2 id="3、Docker的组成"><a href="#3、Docker的组成" class="headerlink" title="3、Docker的组成"></a>3、Docker的组成</h2><p>Docker是传统的CS架构分为 docker client 和 docker server；</p><pre class=" language-shell"><code class="language-shell">[root@master ~]# docker versionClient: Docker Engine - Community Version:           19.03.2 API version:       1.39 (downgraded from 1.40) Go version:        go1.12.8 Git commit:        6a30dfc Built:             Thu Aug 29 05:28:55 2019 OS/Arch:           linux/amd64 Experimental:      falseServer: Docker Engine - Community Engine:  Version:          18.09.9  API version:      1.39 (minimum version 1.12)  Go version:       go1.11.13  Git commit:       039a7df  Built:            Wed Sep  4 16:22:32 2019  OS/Arch:          linux/amd64  Experimental:     false</code></pre><p>Docker主要组件有：镜像、容器、网络、存储、仓库；</p><p>Docker是一种软件的打包技术。</p><h2 id="4、Docker的使用"><a href="#4、Docker的使用" class="headerlink" title="4、Docker的使用"></a>4、Docker的使用</h2><blockquote><p>Docker容器内的第一个进程（初始命令）必须一直处于前台运行的状态（必须夯住），否则这个容器，就会处于退出状态！</p></blockquote><h3 id="4-1镜像管理"><a href="#4-1镜像管理" class="headerlink" title="4.1镜像管理"></a>4.1镜像管理</h3><p>由于国内网络原因，所以我们需要配置Docker【hub.docker.com】中国官方镜像加速：</p><pre class=" language-shell"><code class="language-shell">vi  /etc/docker/daemon.json{  "registry-mirrors": ["https://registry.docker-cn.com"]}</code></pre><p><strong>这里我再介绍一种扩展的方法：</strong></p><p>在官方镜像源基础上，使用python脚本将需要pull的（k8s.gcr.io、gcr.io、quay.io、docker.io）镜像自动转到国内代理站下载，下面时python脚本，可以放在/usr/local/bin目录下直接调用即可。</p><pre class=" language-shell"><code class="language-shell">cat >/usr/local/bin/dockerpull<<eof #! usr bin python # coding="utf8" utf8 without bom import os sys gcr.io xxx yyy:zzz -> gcr.azk8s.cn/xxx/yyy:zzz, for example gcr.io/google_containers/kube-apiserver:v1.14.1#  k8s.gcr.io/xxx:yyy => gcr.io/google-containers/xxx:yyy -> gcr.azk8s.cn/google-containers/xxx:yyy, for example k8s.gcr.io/kube-apiserver:v1.14.1#  quay.io/xxx/yyy:zzz -> quay.azk8s.cn/xxx/yyy:zzz, for example quay.io/coreos/flannel:v0.10.0-amd64converts = [    {        'prefix': 'gcr.io',        'replace': lambda x: x.replace('gcr.io', 'gcr.azk8s.cn'),    },    {        'prefix': 'k8s.gcr.io',        'replace': lambda x: x.replace('k8s.gcr.io', 'gcr.azk8s.cn/google-containers'),    },    {        'prefix': 'quay.io',        'replace': lambda x: x.replace('quay.io', 'quay.azk8s.cn'),    }]def execute_sys_cmd(cmd):    result = os.system(cmd)    if result != 0:        print(cmd + " failed.")        sys.exit(-1)def usage():    print("Usage: " + sys.argv[0] + " pull ${image}")if __name__ == "__main__":    if len(sys.argv) != 3:        usage()        sys.exit(-1)    image = sys.argv[2]    imageArray = image.split("/")     newImage = ''     for cvt in converts:        if imageArray[0] == cvt['prefix']:            newImage = cvt['replace'](image)            break    if newImage:        print("-- pull {image} from {newimage} instead --".format(image=image, newimage=newImage))        cmd = "docker pull {image}".format(image=newImage)        execute_sys_cmd(cmd)        cmd = "docker tag {newImage} {image}".format(newImage=newImage, image=image)        execute_sys_cmd(cmd)        cmd = "docker rmi {newImage}".format(newImage=newImage)        execute_sys_cmd(cmd)           print("-- pull {image} done --".format(image=image))        sys.exit(0)    else:        cmd = "docker pull {image}".format(image=image)        execute_sys_cmd(cmd)        sys.exit(0)EOFchmod +x /usr/local/bin/dockerpull#可以使用如下镜像做下载测试，注意这里版本一定要写正确，如果可以下载则代表镜像站正常：dockerpull pull k8s.gcr.io/kubernetes-dashboard-amd64:v1.10.1dockerpull pull gcr.io/jenkinsxio/prow/crier:v20190510-3f2c8d788dockerpull pull quay.io/coreos/etcd:v3.3dockerpull pull nginx</eof></code></pre><p><strong>常用的Docker镜像管理命令：</strong></p><table><thead><tr><th align="left">功能</th><th align="left">命令</th></tr></thead><tbody><tr><td align="left">拉取镜像</td><td align="left">docker pull [镜像名称:版本]</td></tr><tr><td align="left">镜像列表</td><td align="left">docker images</td></tr><tr><td align="left">导入镜像</td><td align="left">docker load -i [镜像tar包名称]</td></tr><tr><td align="left">导出镜像</td><td align="left">docker save -o [镜像tar包名称] [镜像名称:版本]</td></tr><tr><td align="left">dockerfile自动构建镜像</td><td align="left">docker build -t [镜像名称:版本] [dockerfile文件目录]</td></tr><tr><td align="left">将容器提交为新镜像</td><td align="left">docker commit [容器名称] [新镜像名称:新版本]</td></tr><tr><td align="left">删除镜像</td><td align="left">docker rmi [镜像名称:版本]</td></tr><tr><td align="left">镜像操作记录</td><td align="left">docker history [镜像名称:版本]</td></tr><tr><td align="left">给镜像设置新的仓库</td><td align="left">docker tag [镜像名称:版本] [新镜像名称:新版本]</td></tr><tr><td align="left">查看镜像详细</td><td align="left">docker inspect [镜像名称:版本]</td></tr><tr><td align="left">搜索镜像</td><td align="left">docker search [关键字]</td></tr><tr><td align="left">仓库登录</td><td align="left">docker login</td></tr><tr><td align="left">向仓库推送镜像</td><td align="left">docker push [仓库地址/镜像名称:版本]</td></tr></tbody></table><blockquote><p>docker tag 指令得到了一个新的，和原来的镜像一模一样的镜像，后续文谈到私仓非常有用。</p></blockquote><h3 id="4-2容器管理"><a href="#4-2容器管理" class="headerlink" title="4.2容器管理"></a>4.2容器管理</h3><table><thead><tr><th align="left">功能</th><th align="left">命令</th></tr></thead><tbody><tr><td align="left">启动容器并进入</td><td align="left">docker run -it –name [容器名称] [镜像名称:版本] bash</td></tr><tr><td align="left">容器列表</td><td align="left">docker ps -a (-l –no-trunc)</td></tr><tr><td align="left">显示 Docker 系统信息，包括镜像和容器数</td><td align="left">docker info  【zabbix监控项】</td></tr><tr><td align="left">容器提交为新的镜像</td><td align="left">docker commit [容器名称] my_image:v1.0</td></tr><tr><td align="left">容器后台运行</td><td align="left">docker run -d –name [容器名称] [镜像名称:版本]</td></tr><tr><td align="left">容器结束后自动删除</td><td align="left">docker run –rm –name [容器名称] [镜像名称:版本]</td></tr><tr><td align="left">删除容器</td><td align="left">docker rm [容器名称]</td></tr><tr><td align="left">删除所有停止状态的容器</td><td align="left">docker container prune</td></tr><tr><td align="left">进入容器 exec 【新终端】</td><td align="left">docker exec -it [容器名称] bash</td></tr><tr><td align="left">进入容器 attach</td><td align="left">docker attach –sig-proxy=false [容器名称]</td></tr><tr><td align="left">停止容器</td><td align="left">docker stop [容器名称]</td></tr><tr><td align="left">Docker 日志</td><td align="left">docker logs [容器名称]</td></tr><tr><td align="left">查看容器详细</td><td align="left">docker inspect [容器名称]</td></tr><tr><td align="left">查看容器最近一个进程</td><td align="left">docker top [容器名称]</td></tr><tr><td align="left">继续运行被停止的容器</td><td align="left">docker restart [容器名称]</td></tr><tr><td align="left">暂停一个容器进程</td><td align="left">docker pause [容器名称]</td></tr><tr><td align="left">取消暂停</td><td align="left">docker unpause [容器名称]</td></tr><tr><td align="left">终止容器</td><td align="left">docker kill [容器名称]</td></tr><tr><td align="left">端口映射</td><td align="left">docker run -it –name [容器名称] -p 8080:80 [镜像名称:版本] bash</td></tr><tr><td align="left">容器互联【单方向的】</td><td align="left">docker run -ti –name [容器名称] –link [被互联容器名称]:[容器内名称] nginx:v1.0 bash</td></tr><tr><td align="left">复制容器文件到宿主</td><td align="left">docker cp [容器名称]:[容器内目录] ./</td></tr><tr><td align="left">设置环境变量</td><td align="left">docker run -d -e MYSQL_ROOT_PASSWORD=123456 -p 3306:3306 mysql:5.7</td></tr></tbody></table><blockquote><p>docker ps -a -q 其中-q静默输出，可以显示所有容器的id，我们可以利用这个做批量启动、删除等操作，如docker rm -f `docker ps -a -q`可以清空所有容器；</p></blockquote><ul><li><code>exec</code>与 <code>attach</code>登陆容器的区别</li></ul><blockquote><p>在 exec 里面执行 exit 命令，你只是关掉了 exec 命令新开的进程，而主进程依旧在运行，所以容器并不会停止；<br>在 attach 里面运行 exit 命令，你实际是终止了主进程，所以容器也就随之被停止了；</p></blockquote><ul><li><code>-p</code> 端口映射配置</li></ul><blockquote><p>指定映射(docker 会自动添加一条iptables规则来实现端口映射)<br>-p hostPort:containerPort<br>-p ip:hostPort:containerPort     指定IP的端口映射<br>-p ip::containerPort(随机端口)<br>-p hostPort:containerPort/udp<br>-p  10.0.0.100::53/udp   使用宿主机的10.0.0.100这个ip地址的随机端口的udp协议映射容器的udp53端口<br>-p 81:80 –p 443:443 可以指定多个-p</p></blockquote><ul><li><code>-e</code>环境变量配置</li></ul><p>例如MySQL镜像环境变量如下（-e可以有多个）：</p><blockquote><p>MYSQL_ROOT_PASSWORD=xxx<br>#root用户的密码；<br>MYSQL_DATABASE=xxx<br>#运行时需要创建的数据库名称；<br>MYSQL_USER=xxx<br>#运行时需要创建用户名，与MYSQL_PASSWORD一起使用；<br>MYSQL_PASSWORD=xxx<br>#运行时需要创建的用户名对应的密码，与MYSQL_USER一起使用；<br>MYSQL_ALLOW_EMPTY_PASSWORD=yes #不常用<br>#是否允许root用户的密码为空，该参数对应的值为:yes|no；<br>MYSQL_RANDOM_ROOT_PASSWORD=xxx #不常用<br>#为root用户生成随机密码；<br>MYSQL_ONETIME_PASSWORD=xxx #不常用<br>#设置root用户的密码必须在第一次登陆时修改（只对5.6以上的版本支持）；<br>#MYSQL_ROOT_PASSWORD 和 MYSQL_RANDOM_ROOT_PASSWORD 两者必须有且只有一个。</p></blockquote><ul><li><code>--link</code>容器互联配置</li></ul><blockquote><p>容器间互联，这个参数实质就是在容器的/etc/hosts文件中添加解析，而且只在使用–link参数的可以访问，所以这种网络互联是单向的。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;云计算之Docker-基础&quot;&gt;&lt;a href=&quot;#云计算之Docker-基础&quot; class=&quot;headerlink&quot; title=&quot;云计算之Docker 基础&quot;&gt;&lt;/a&gt;云计算之Docker 基础&lt;/h1&gt;&lt;h2 id=&quot;1、容器的定义&quot;&gt;&lt;a href=&quot;#1、容器的定义&quot; class=&quot;headerlink&quot; title=&quot;1、容器的定义&quot;&gt;&lt;/a&gt;1、容器的定义&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;容器就是在隔离的环境运行的一个进程，如果进程停止，容器就会退出；&lt;/li&gt;
&lt;li&gt;隔离的环境拥有自己的系统文件，ip 地址，主机名等；&lt;/li&gt;
&lt;li&gt;相比虚拟化，容器更加轻便、快捷高效、快速回滚，共用宿主机内核；&lt;/li&gt;
&lt;li&gt;容器是linux内核独有的技术;&lt;/li&gt;
&lt;li&gt;目前最常用的容器 Docker（基于 lxc 重构）。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Docker" scheme="http://lpcsf.git.io/categories/Docker/"/>
    
    
      <category term="云计算" scheme="http://lpcsf.git.io/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="DOCKER" scheme="http://lpcsf.git.io/tags/DOCKER/"/>
    
  </entry>
  
  <entry>
    <title>OSI 七层模式</title>
    <link href="http://lpcsf.git.io/2019/10/29/OSI%20%E4%B8%83%E5%B1%82%E6%A8%A1%E5%BC%8F/"/>
    <id>http://lpcsf.git.io/2019/10/29/OSI 七层模式/</id>
    <published>2019-10-29T13:25:50.661Z</published>
    <updated>2019-10-29T13:29:56.147Z</updated>
    
    <content type="html"><![CDATA[<hr><hr><h3 id="OSI-七层模式"><a href="#OSI-七层模式" class="headerlink" title="OSI 七层模式"></a>OSI 七层模式</h3><p><img src="E:%5C%E8%80%81%E7%94%B7%E5%AD%A9%E5%AD%A6%E4%B9%A0%5Cmd%E5%9B%BE%E7%89%87%5Cassets%5Cimage-20191029210227477.png" alt="image-20191029210227477"></p><h3 id="OSI-七层模式详解"><a href="#OSI-七层模式详解" class="headerlink" title="OSI 七层模式详解"></a>OSI 七层模式详解</h3><h5 id="物理层-Physical-Layer"><a href="#物理层-Physical-Layer" class="headerlink" title="物理层/Physical Layer"></a>物理层/Physical Layer</h5><p>物理层规定物理设备，物理线路和设备的触发、维护、关闭物理设备的机械特性</p><p>实际最终的传输也是通过物理层实现的</p><a id="more"></a><h5 id="数据链路层-Data-Link-Layer"><a href="#数据链路层-Data-Link-Layer" class="headerlink" title="数据链路层/Data Link Layer"></a>数据链路层/Data Link Layer</h5><p>在物理介质的基础上提供可靠的传输，在这一层利用通信信道实现了无差错的传输</p><p>提供了物理寻址(MAC)、数据成帧，数据的检测和重发，流量控制和链路控制等功能</p><h5 id="网络层-NetWork-Layer"><a href="#网络层-NetWork-Layer" class="headerlink" title="网络层/ NetWork Layer"></a>网络层/ NetWork Layer</h5><p>将各个子网的数据进行路由选择</p><p>将数据从一个主机传送到另一个主机</p><p>功能：网际互联  流量控制   行为管理</p><p>这一层数据传输 单位为数据包<code>packet</code></p><p>协议：IP  ICMP IPX</p><h5 id="传输层-Transport-Layer"><a href="#传输层-Transport-Layer" class="headerlink" title="传输层/ Transport Layer"></a>传输层/ Transport Layer</h5><p>传输层把上一层数据进行分段处理，可以提供可靠的传输<code>TPC</code>或不可靠的传输<code>UDP</code></p><p>起到了为上层掩盖下层的细节。保证会话层的数据信息能够传送到别一个的会话层</p><p>协议：TCP UPD  SPX 等</p><h5 id="会话层-Session-Layer"><a href="#会话层-Session-Layer" class="headerlink" title="会话层//Session Layer"></a>会话层//Session Layer</h5><p>负责建立、管理和终止表示层实体之间的通信会话。该层的通信由不同设备中的应用程序之间的服务请求和响应组成。 </p><h5 id="表示层-Presentation-Layer"><a href="#表示层-Presentation-Layer" class="headerlink" title="表示层/Presentation Layer"></a>表示层/Presentation Layer</h5><p>对数据的格式进行转换，使得多个主键之间传送的信息能够互相的理解。</p><p>数据压缩和加密也是表示层可提供的转换功能之一</p><p>协议：ASCII JPEG PNG MPEG 等标准</p><h5 id="应用层-Application-Layer"><a href="#应用层-Application-Layer" class="headerlink" title="应用层/Application Layer"></a>应用层/Application Layer</h5><p>作用：计算机用户提供应用接口，也为用户直接提供各种网络服务。</p><p>协议：HTTP  HTTPS FTP  POP3 SMTP等</p><h3 id="TCP-IP-五层模型"><a href="#TCP-IP-五层模型" class="headerlink" title="TCP/IP 五层模型"></a>TCP/IP 五层模型</h3><blockquote><p>TCP/IP五层协议和OSI的七层协议对应关系如下。</p></blockquote><p><img src="E:%5C%E8%80%81%E7%94%B7%E5%AD%A9%E5%AD%A6%E4%B9%A0%5Cmd%E5%9B%BE%E7%89%87%5Cassets%5Cimage-20191029211715292.png" alt="image-20191029211715292"></p><h3 id="OSI-模型-每一层工作的设备"><a href="#OSI-模型-每一层工作的设备" class="headerlink" title="OSI 模型 每一层工作的设备"></a>OSI 模型 每一层工作的设备</h3><p><img src="E:%5C%E8%80%81%E7%94%B7%E5%AD%A9%E5%AD%A6%E4%B9%A0%5Cmd%E5%9B%BE%E7%89%87%5Cassets%5Cimage-20191029211801916.png" alt="image-20191029211801916"></p><h3 id="OSI模型-每层主要的协议"><a href="#OSI模型-每层主要的协议" class="headerlink" title="OSI模型 每层主要的协议"></a>OSI模型 每层主要的协议</h3><p><img src="E:%5C%E8%80%81%E7%94%B7%E5%AD%A9%E5%AD%A6%E4%B9%A0%5Cmd%E5%9B%BE%E7%89%87%5Cassets%5Cimage-20191029211831097.png" alt="image-20191029211831097"></p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;&lt;hr&gt;&lt;h3 id=&quot;OSI-七层模式&quot;&gt;&lt;a href=&quot;#OSI-七层模式&quot; class=&quot;headerlink&quot; title=&quot;OSI 七层模式&quot;&gt;&lt;/a&gt;OSI 七层模式&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;E:%5C%E8%80%81%E7%94%B7%E5%AD%A9%E5%AD%A6%E4%B9%A0%5Cmd%E5%9B%BE%E7%89%87%5Cassets%5Cimage-20191029210227477.png&quot; alt=&quot;image-20191029210227477&quot;&gt;&lt;/p&gt;&lt;h3 id=&quot;OSI-七层模式详解&quot;&gt;&lt;a href=&quot;#OSI-七层模式详解&quot; class=&quot;headerlink&quot; title=&quot;OSI 七层模式详解&quot;&gt;&lt;/a&gt;OSI 七层模式详解&lt;/h3&gt;&lt;h5 id=&quot;物理层-Physical-Layer&quot;&gt;&lt;a href=&quot;#物理层-Physical-Layer&quot; class=&quot;headerlink&quot; title=&quot;物理层/Physical Layer&quot;&gt;&lt;/a&gt;物理层/Physical Layer&lt;/h5&gt;&lt;p&gt;物理层规定物理设备，物理线路和设备的触发、维护、关闭物理设备的机械特性&lt;/p&gt;&lt;p&gt;实际最终的传输也是通过物理层实现的&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>shell - day02</title>
    <link href="http://lpcsf.git.io/2019/10/29/shell%20-%20day02/"/>
    <id>http://lpcsf.git.io/2019/10/29/shell - day02/</id>
    <published>2019-10-29T12:48:11.370Z</published>
    <updated>2019-10-27T12:43:31.821Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="三、条件测试表达式-非if"><a href="#三、条件测试表达式-非if" class="headerlink" title="三、条件测试表达式 ( 非if)"></a>三、条件测试表达式 ( 非if)</h2><h3 id="1、shell的条件测试"><a href="#1、shell的条件测试" class="headerlink" title="1、shell的条件测试"></a>1、shell的条件测试</h3><blockquote><p>是验证条件是否符合预期。以下是常用语法</p></blockquote><table><thead><tr><th align="left">条件测试语法</th><th>说明</th></tr></thead><tbody><tr><td align="left">test &lt;测试表达式&gt;</td><td>利用test命令测试条件表达式。</td></tr><tr><td align="left">[ &lt;测试表达式&gt; ]</td><td>通过[]测试条件表达式的方法，和test命令的用法相同，**注</td></tr><tr><td align="left">[[ &lt;测试表达式&gt; ]]</td><td>通过[[]]测试条件表达式的值的方法，是比test和[]更新的语法格式。</td></tr><tr><td align="left">((测试表达式))</td><td>通过<code>(())</code>进行测试条件表达式的方法，一般用于if语句里。</td></tr></tbody></table><a id="more"></a><p> <strong>针对以上表有几个注意事项需要说明：</strong></p><ul><li><p>在双中括号[[]]中可以使用通配符（如*）等进行模式匹配，这是区别于其他几种语法的地方</p></li><li><p>&amp;&amp;、||、&gt;、&lt;等操作符可以应用到[[]]中，但不能应用于[]中，在[]中一般用-a、-o、-gt、-lt取代</p></li><li><p>对于整数的关系运算，也可以使用Shell的算术运算符(())</p></li></ul><h3 id="2、文件测试表达式"><a href="#2、文件测试表达式" class="headerlink" title="2、文件测试表达式"></a>2、文件测试表达式</h3><p>对于文件测试表达式中，常用的文件测试操作符如下所示：</p><table><thead><tr><th>表达式</th><th>说明</th></tr></thead><tbody><tr><td>[ -f file ]，f的全称为file</td><td>文件存在</td></tr><tr><td>[ -e file ]，e的全称为exist</td><td>文件(夹)存在</td></tr><tr><td>[ -d dir ]，d的全称为directory</td><td>是目录</td></tr><tr><td>[ -L file ]，L的全称为link</td><td>是软链接</td></tr><tr><td>[ -s file ]，s的全称为size</td><td>文件存在且非空</td></tr><tr><td>[ -S file ]，S的全称为Socket</td><td>文件是Socket文件</td></tr><tr><td>[ -r file ]，r的全称为read</td><td>文件可读</td></tr><tr><td>[ -w file ]，w的全称为write</td><td>文件可写</td></tr><tr><td>[ -x file ]，x的全称为executable</td><td>文件可执行</td></tr></tbody></table><h3 id="3、字符串测试表达式"><a href="#3、字符串测试表达式" class="headerlink" title="3、字符串测试表达式"></a>3、字符串测试表达式</h3><blockquote><p>比较两个字符是否相同、测试字符串的长度是否为0、字符串是否为NULL等，</p></blockquote><p> 常用的字符串操作符如下所示：</p><table><thead><tr><th>表达式</th><th>说明</th></tr></thead><tbody><tr><td>[ “$a” = “$b” ]</td><td>测试字符串是否相等。用作赋值时两边不能有空格，用做判断时必须有空格。</td></tr><tr><td>[ “$a” != “$b” ]</td><td>测试字符串是否不相等</td></tr><tr><td>[ -n “$str” ]</td><td>判断字符串是否非空</td></tr><tr><td>[ -z “$str” ]</td><td>判断字符串是否为空</td></tr><tr><td>[ $str ]</td><td>判断字符串是否非空，类似于 -n</td></tr></tbody></table><h3 id="4、整数二元比较操作符"><a href="#4、整数二元比较操作符" class="headerlink" title="4、整数二元比较操作符"></a>4、整数二元比较操作符</h3><p>整数二元比较操作符使用参考</p><table><thead><tr><th>在[]以及test中使用的比较符号</th><th>在(())和[[]]中使用的比较符号</th><th>说明</th></tr></thead><tbody><tr><td>-eq</td><td>==或=</td><td>相等的英文equal</td></tr><tr><td>-ne</td><td>!=</td><td>不相等的英文not equal</td></tr><tr><td>-gt</td><td>&gt;</td><td>大于的英文greater than</td></tr><tr><td>-ge</td><td>&gt;=</td><td>大于等于的英文greater equal</td></tr><tr><td>-lt</td><td>&lt;</td><td>小于的英文less than</td></tr><tr><td>-le</td><td>&lt;=</td><td>小于等于的英文less equal</td></tr></tbody></table><p><strong>注意：不推荐使用[[]]比较数字，因为在大小比较中，[[]]比较的是字符串的arscII码</strong></p><h3 id="5、有关-、-、-用法小结"><a href="#5、有关-、-、-用法小结" class="headerlink" title="5、有关[]、[[]]、(())用法小结"></a>5、有关<code>[]</code>、<code>[[]]</code>、<code>(())</code>用法小结</h3><ul><li>整数加双引号比较也可以</li><li><code>[[]]</code> 中使用类似 <code>-eq</code> 的写法是正确的，而<code>[[]]</code> 中类似<code>&gt;</code>,<code>&lt;</code>的写法可能不对</li><li><code>[[]]</code>中用类似<code>&gt;</code>、<code>&lt;</code>的写法语法没错（经过转义），但是逻辑结果不对，使用<code>=</code>、<code>!=</code>可以正确比较</li><li><code>(())</code>中不能使用类似<code>-eq</code>的写法，可以使用类似<code>&gt;</code>、<code>&lt;</code>、<code>==</code>（=不可以）的写法</li></ul><h2 id="四、if-条件语句"><a href="#四、if-条件语句" class="headerlink" title="四、if 条件语句"></a>四、if 条件语句</h2><blockquote><p>if条件语句，简单来说，其语义类似于汉语中的“如果…那么…”。<br>if语句是Linux运维人员在实际生产过程中使用的最频繁也是最重要的语句。  </p></blockquote><h3 id="4-1-单分支"><a href="#4-1-单分支" class="headerlink" title="4.1 单分支"></a>4.1 单分支</h3><blockquote><p>if条件语句的单分支结构主体是“如果…那么…”</p></blockquote><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a><strong>语法</strong></h4><pre class=" language-shell"><code class="language-shell"># 第一种语法if <条件表达式>then    指令fi# 第二种语法if <条件表达式>;then    指令fi</条件表达式></条件表达式></code></pre><blockquote><p>上文中的“&lt;条件表达式&gt;”位置部分，可以使用test、[]、[[]]、(())等条件表达式</p></blockquote><h4 id="if-表达式嵌套"><a href="#if-表达式嵌套" class="headerlink" title="if 表达式嵌套"></a>if 表达式嵌套</h4><pre class=" language-shell"><code class="language-shell">if <条件表达式>;then    if <条件表达式>;then        指令    fifi</条件表达式></条件表达式></code></pre><h4 id="和之前条件表达式的关系"><a href="#和之前条件表达式的关系" class="headerlink" title="和之前条件表达式的关系"></a>和之前条件表达式的关系</h4><p>if条件语句相对于之前讲过的文件表达式[ -f “$file” ] &amp;&amp; echo 1等价于下面的if语句</p><pre class=" language-shell"><code class="language-shell">if [ -f “file”]; then  echo 1fi</code></pre><p>if条件语句的单分支，如果形象的使用中文解释的话，相当于一个女孩这么对你说：</p><pre class=" language-shell"><code class="language-shell">如果 <你有房>;那么    我就嫁给你果如</你有房></code></pre><h3 id="4-2-双分支"><a href="#4-2-双分支" class="headerlink" title="4.2 双分支"></a>4.2 双分支</h3><blockquote><p>if条件语句的双分支结构主体则为“如果…那么…否则…”  </p></blockquote><h4 id="4-2-1-语法"><a href="#4-2-1-语法" class="headerlink" title="4.2.1 语法"></a>4.2.1 语法</h4><pre class=" language-shell"><code class="language-shell">if <条件表达式>;then    指令集1else    指令集2fi</条件表达式></code></pre><h4 id="4-2-2-和之前条件表达式的关系"><a href="#4-2-2-和之前条件表达式的关系" class="headerlink" title="4.2.2 和之前条件表达式的关系"></a>4.2.2 和之前条件表达式的关系</h4><blockquote><p>前文的文件测试表达式<code>[ -f “file” ] &amp;&amp; echo 1 || echo 0</code>就相当于下面的双分支的if条件语句</p></blockquote><pre class=" language-shell"><code class="language-shell">if [ -f “file”]; then    echo 1else    echo 0fi</code></pre><h3 id="4-3-多分支"><a href="#4-3-多分支" class="headerlink" title="4.3 多分支"></a>4.3 多分支</h3><blockquote><p>if条件语句多分支结构主体为“如果…，那么…，否则如果…，那么… 否则如果…，那么…，否则</p></blockquote><h4 id="4-3-1多分支语法"><a href="#4-3-1多分支语法" class="headerlink" title="4.3.1多分支语法"></a>4.3.1多分支语法</h4><pre class=" language-shell"><code class="language-shell">if <条件表达式>;then    指令集1elif <条件表达式>;then    指令集2else    指令集3fi</条件表达式></条件表达式></code></pre><h2 id="五、函数"><a href="#五、函数" class="headerlink" title="五、函数"></a>五、函数</h2><blockquote><p>简单的说，函数的作用就是将程序里面多次被调用的相同代码组合起来(函数体)，并为其取个名字（函数名）。其他所有想重复调用这部分代码的地方，只需要调用这个名字就好了。</p></blockquote><h3 id="5-1-shell-函数的优势"><a href="#5-1-shell-函数的优势" class="headerlink" title="5.1 shell 函数的优势"></a>5.1 shell 函数的优势</h3><ul><li>把相同的程序段定义成函数，可以减少整个程序的代码量，提高开发效率</li><li>增加程序的可读，易读性，提升管理效率</li><li>可以实习爱你程序功能模块化，使得程序具备通用型(可移植性)</li></ul><h3 id="5-2-函数语法"><a href="#5-2-函数语法" class="headerlink" title="5.2 函数语法"></a>5.2 函数语法</h3><h4 id="shell-函数的常见语法格式"><a href="#shell-函数的常见语法格式" class="headerlink" title="shell 函数的常见语法格式"></a>shell 函数的常见语法格式</h4><pre class=" language-shell"><code class="language-shell">function 函数名(){   # 推荐书写函数的方法（带括号）    指令集...    return n}</code></pre><h4 id="简化写法-1"><a href="#简化写法-1" class="headerlink" title="简化写法 1"></a>简化写法 1</h4><pre class=" language-SHELL"><code class="language-SHELL">function 函数名 {   # 不推荐使用此方法（无括号，函数名和左花括号之间需要有空格。）    指令集...    return n}</code></pre><h4 id="简化写法-2"><a href="#简化写法-2" class="headerlink" title="简化写法 2"></a>简化写法 2</h4><pre class=" language-shell"><code class="language-shell">函数名(){   # 不用function的方法    指令集...    return n}</code></pre><h3 id="5-3-函数执行"><a href="#5-3-函数执行" class="headerlink" title="5.3 函数执行"></a>5.3 函数执行</h3><blockquote><p>shell 函数分为最基本的函数和可以传参的函数俩种</p><p>定义函数的代码段<strong>不会自动执行</strong>，<strong>在调用时执行</strong>；调用即在代码中给定函数并即可； </p></blockquote><h4 id="不带参数的函数"><a href="#不带参数的函数" class="headerlink" title="不带参数的函数"></a>不带参数的函数</h4><pre class=" language-shell"><code class="language-shell">[root@shell ~]# cat demo1.sh #!/bin/bash# 定义函数demoFUN(){    echo " the is shell !!!"}#调用函数demoFUN#  执行结果[root@shell ~]# sh demo2.sh  the is shell !!!</code></pre><h4 id="带参数的函数"><a href="#带参数的函数" class="headerlink" title="带参数的函数"></a>带参数的函数</h4><pre class=" language-shell"><code class="language-shell">[root@shell ~]# cat func1.sh #!/bin/bashfunction hello(){    echo "hello $1"}hello word！[root@shell ~]# sh func1.sh hello word！</code></pre><h2 id="六、case-语句"><a href="#六、case-语句" class="headerlink" title="六、case 语句"></a>六、case 语句</h2><p>  case结构条件句相当于多分支的if/elif/else条件句，但是它比这些条件句看起来更规范公正，常被用于实现系统服务启动脚本等企业应用场景中。</p><h3 id="6-1-case-语法"><a href="#6-1-case-语法" class="headerlink" title="6.1 case 语法"></a>6.1 case 语法</h3><pre class=" language-shell"><code class="language-shell">case “变量” in 值1)    指令1...    ;;值2)    指令2...    ;;*)    指令3...esac</code></pre><h3 id="6-2-case-语句流程图"><a href="#6-2-case-语句流程图" class="headerlink" title="6.2 case 语句流程图"></a>6.2 case 语句流程图</h3><p><img src="E:%5C%E8%80%81%E7%94%B7%E5%AD%A9%E5%AD%A6%E4%B9%A0%5Cmd%E5%9B%BE%E7%89%87%5Cassets%5Cimage-20191027174808798.png" alt="image-20191027174808798"></p><h3 id="6-3-case-实例"><a href="#6-3-case-实例" class="headerlink" title="6.3 case 实例"></a>6.3 case 实例</h3><pre class=" language-shell"><code class="language-shell">[root@shell ~]# cat 1.sh echo '输入 1 到 4 之间的数字:'read -p '你输入的数字为:' aNumcase $aNum in    1)  echo '你选择了 1'    ;;    2)  echo '你选择了 2'    ;;    3)  echo '你选择了 3'    ;;    4)  echo '你选择了 4'    ;;    *)  echo '你没有输入 1 到 4 之间的数字'    ;;esac[root@shell ~]# sh 1.sh 输入 1 到 4 之间的数字:你输入的数字为:2你选择了 2[root@shell ~]# sh 1.sh 输入 1 到 4 之间的数字:你输入的数字为:6你没有输入 1 到 4 之间的数字</code></pre><h2 id="七、while-循环"><a href="#七、while-循环" class="headerlink" title="七、while 循环"></a>七、while 循环</h2><p>while 循环又称之为死循环，常用于重复执行一条指令或一组指令，直到条件不满足停止。</p><p>在企业中常用于守护进程或持续运行的程序，也有时候会用while来读取文件的每一行内容。</p><p>while循环会对紧跟在while后的条件表达式判断，如果条件成立，就执行while里面的命令或语句，每次执行到done时候就重新判断while表达式是否真的成立，直到表达式不成立才退出。</p><h4 id="7-1-while-语法"><a href="#7-1-while-语法" class="headerlink" title="7.1 while 语法"></a>7.1 while 语法</h4><pre class=" language-shell"><code class="language-shell"># 写法1while <条件表达式>do    指令done# 写法2while <条件表达式>;do    指令done</条件表达式></条件表达式></code></pre><p>while 实例</p><pre class=" language-shell"><code class="language-shell">[root@shell ~]# cat 3.sh #!/bin/basha=1while [ $a -lt 3 ]do  echo $a  let a=a+1done# 执行结果[root@shell ~]# sh 3.sh 12</code></pre><h3 id="7-2-while循环执行的流程图如下所示："><a href="#7-2-while循环执行的流程图如下所示：" class="headerlink" title="7.2 while循环执行的流程图如下所示："></a>7.2 while循环执行的流程图如下所示：</h3><p><img src="E:%5C%E8%80%81%E7%94%B7%E5%AD%A9%E5%AD%A6%E4%B9%A0%5Cmd%E5%9B%BE%E7%89%87%5Cassets%5Cimage-20191027180048283.png" alt="image-20191027180048283"></p><h3 id="7-3-while-按行读入文件"><a href="#7-3-while-按行读入文件" class="headerlink" title="7.3 while 按行读入文件"></a>7.3 while 按行读入文件</h3><blockquote><p>while可以读取指定的文件，然后可以对每行数据进行自定义处理  </p></blockquote><ul><li><code>&lt;</code> 重定向输入方式(推荐使用的方式)</li></ul><pre class=" language-sh"><code class="language-sh">while read linedo    echo $linedone < file</code></pre><ul><li>cat 方式 </li></ul><pre class=" language-shell"><code class="language-shell">cat file | while read linedo     echo $linedone</code></pre><p>while 按行读入 实例</p><pre class=" language-shell"><code class="language-shell"># 文件内容[root@shell ~]# cat one.txt 123# 脚本内容[root@shell ~]# cat 4.sh #!/bin/bashwhile read line do  echo $linedone < one.txt# 执行结果[root@shell ~]# sh 4.sh 123</code></pre><h2 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h2><h3 id="for-语法"><a href="#for-语法" class="headerlink" title="for 语法"></a>for 语法</h3><ul><li>第一种是 for 为变量取值行</li></ul><pre class=" language-shell"><code class="language-shell">for 变量名 in 变量取值列表do    指令done</code></pre><ul><li>第二种称之为C语言型for循环语句</li></ul><pre class=" language-shell"><code class="language-shell">for((exp1;exp2;exp3))do    指令done</code></pre><p>for 语句举例</p><pre class=" language-shell"><code class="language-shell">[root@shell ~]# cat for01.sh #!/bin/bashfor i in 1 2 3 do    echo "the is $i"done# [root@shell ~]# sh for01.sh the is 1the is 2the is 3[root@shell ~]# cat for02.sh #!/bin/bashfor (( i=0;i<5;i++ 0 1 )) do echo $i done [root@shell ~]# sh for02.sh 2< code></5;i++></code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;&lt;h2 id=&quot;三、条件测试表达式-非if&quot;&gt;&lt;a href=&quot;#三、条件测试表达式-非if&quot; class=&quot;headerlink&quot; title=&quot;三、条件测试表达式 ( 非if)&quot;&gt;&lt;/a&gt;三、条件测试表达式 ( 非if)&lt;/h2&gt;&lt;h3 id=&quot;1、shell的条件测试&quot;&gt;&lt;a href=&quot;#1、shell的条件测试&quot; class=&quot;headerlink&quot; title=&quot;1、shell的条件测试&quot;&gt;&lt;/a&gt;1、shell的条件测试&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;是验证条件是否符合预期。以下是常用语法&lt;/p&gt;
&lt;/blockquote&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;left&quot;&gt;条件测试语法&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;test &amp;lt;测试表达式&amp;gt;&lt;/td&gt;
&lt;td&gt;利用test命令测试条件表达式。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;[ &amp;lt;测试表达式&amp;gt; ]&lt;/td&gt;
&lt;td&gt;通过[]测试条件表达式的方法，和test命令的用法相同，**注&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;[[ &amp;lt;测试表达式&amp;gt; ]]&lt;/td&gt;
&lt;td&gt;通过[[]]测试条件表达式的值的方法，是比test和[]更新的语法格式。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;((测试表达式))&lt;/td&gt;
&lt;td&gt;通过&lt;code&gt;(())&lt;/code&gt;进行测试条件表达式的方法，一般用于if语句里。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>shell数组的定义</title>
    <link href="http://lpcsf.git.io/2019/10/29/shell%E6%95%B0%E7%BB%84%E7%9A%84%E5%AE%9A%E4%B9%89/"/>
    <id>http://lpcsf.git.io/2019/10/29/shell数组的定义/</id>
    <published>2019-10-29T12:07:54.326Z</published>
    <updated>2019-10-29T12:14:07.221Z</updated>
    
    <content type="html"><![CDATA[<h1 id="shell数组"><a href="#shell数组" class="headerlink" title="shell数组"></a>shell数组</h1><h3 id="01-shell数组的分类"><a href="#01-shell数组的分类" class="headerlink" title="01. shell数组的分类"></a>01. shell数组的分类</h3><ul><li><strong>普通数组：只能以数字作为索引(也称之为下标)</strong></li><li><strong>关联数组：可以使用字符作为索引</strong></li></ul><h3 id="02-shell数组常用定义方式"><a href="#02-shell数组常用定义方式" class="headerlink" title="02. shell数组常用定义方式"></a>02. shell数组常用定义方式</h3><p>定义普通数组</p><a id="more"></a><pre class=" language-shell"><code class="language-shell">#定义普通数组1：[root@shell ~]# array=(one two three)#定义普通数组2:[root@shell ~]# array=([0]=one [1]=two [2]=three)#定义普通数组3:[root@shell ~]# array[0]=one[root@shell ~]# array[1]=two[root@shell ~]# array[2]=three#不连续的索引赋值，双引号将里面的内容当成一个元素[root@shell ~]# array_1=(oldboy name [5]=linux "centos shell" [10]=kvm)[root@shell ~]# echo ${array_1[*]}oldboy name linux centos shell kvm[root@shell ~]# echo ${!array_1[*]}0 1 5 6 10</code></pre><p>定义管理数组</p><blockquote><p>创建关联数组前需要声明</p></blockquote><pre class=" language-shell"><code class="language-shell">#定义关联数组1:[root@shell ~]# declare -A oldqq[root@shell ~]# oldqq=([index1]=www [index2]=bbs [index3]=zhihu)#定义关联数组2:[root@shell ~]# declare -A oldqq[root@shell ~]# oldqq[index1]=www [root@shell ~]# oldqq[index2]=bbs [root@shell ~]# oldqq[index3]=zhihu</code></pre><h3 id="03-查看shell数组"><a href="#03-查看shell数组" class="headerlink" title="03. 查看shell数组"></a>03. 查看shell数组</h3><p>查看所有定义的普通数组</p><pre class=" language-SHELL"><code class="language-SHELL">[root@shell ~]# declare -a</code></pre><p>查看所有定义的关联数组</p><pre class=" language-shell"><code class="language-shell">[root@shell ~]# declare -A</code></pre><p>查看数组所有元素(*与@都可以)</p><pre class=" language-shell"><code class="language-shell">[root@shell ~]# echo ${array[*]}        one two three[root@shell ~]# echo ${oldqq[@]}index1 index2 index3</code></pre><p>查看数组所有的索引(下标)</p><pre class=" language-SHELL"><code class="language-SHELL">[root@shell ~]# echo ${!array[*]}        0 1 2[root@shell ~]# echo ${oldqq[*]}www bbs zhihu</code></pre><p>查看数组的单个元素</p><pre class=" language-shell"><code class="language-shell">[root@shell ~]# echo ${array[0]}one[root@shell ~]# echo ${array[2]}three[root@shell ~]#  echo ${oldqq[index1]}www[root@shell ~]#  echo ${oldqq[index3]}zhihu</code></pre><h3 id="04-删除shell数组"><a href="#04-删除shell数组" class="headerlink" title="04. 删除shell数组"></a>04. 删除shell数组</h3><p>删除单个数组元素</p><pre class=" language-shell"><code class="language-shell">[root@shell ~]# unset array[3]    #<= 去掉下标为3的数组元素 [root@shell ~]# echo ${array[*]} one two three< code></=></code></pre><p>删除整个数组</p><pre class=" language-shell"><code class="language-shell">[root@shell ~]# unset array         #<= 删除整个数组 [root@shell ~]# echo ${array[*]} #<="内容为空，说明删除成功" < code></=></code></pre><h3 id="05-shell数组内容的截取和替换"><a href="#05-shell数组内容的截取和替换" class="headerlink" title="05. shell数组内容的截取和替换"></a>05. shell数组内容的截取和替换</h3><pre class=" language-shell"><code class="language-shell">[root@shell ~]# array=(a b c d e)    [root@shell ~]# echo ${!array[*]}0 1 2 3 4[root@shell ~]# echo ${array[*]}a b c d e[root@shell ~]# echo ${array[*]:1:3}    #<== 1 截取元素1到元素3(默认元素从0开始) b c d [root@shell ~]# array="($(echo" {a..g})) #<="=" 将变量的结果赋值给数组元素 echo ${array[*]} a e f g ${array[*] 1} 把数组中a替换为1，原数组未被真正修改 #数组也是变量，因此也适合变量的字串处理功能 abcdefg) abcabcabc abcdefg ${array[*]#*c} abcabc defg ${array[*]#*b} cabcabc cdefg ${array[*]##*b} ${array[*]%b*} abcabca ${array[*]%%b*} a< code></==></code></pre><h3 id="06-shell数组循环打印"><a href="#06-shell数组循环打印" class="headerlink" title="06. shell数组循环打印"></a>06. shell数组循环打印</h3><pre class=" language-shell"><code class="language-shell">#通过C语言类型的for循环[root@shell scripts]# cat test01sh#!/bin/bashipadd=(    10.0.0.11    10.0.0.22    10.0.0.33)for((i=0;i<${#ipadd[*]};i++)) do echo "${ipadd[$i]}" done #通过普通for循环 [root@shell scripts]# cat test02sh #! bin bash ipadd="(" 10.0.0.11 10.0.0.22 10.0.0.33 ) for i in ${ipadd[*]} "$i" #两种打印结果是相同的，这里省略.. sh test01h 10.0.0.33< code></${#ipadd[*]};i++))></code></pre><h3 id="07-案例"><a href="#07-案例" class="headerlink" title="07. 案例:"></a>07. 案例:</h3><p> <strong>计算以下数据中性别出现的次数</strong></p><pre class=" language-mysql"><code class="language-mysql">[root@shell ~]# cat sex.txt |column -tzhangsan     malelisi         femalewangwu       malelili         malexx           femalemayun        malemahuateng    malewangjianlin  malecxk          unknown</code></pre><p><strong>编写的脚本</strong></p><pre class=" language-shell"><code class="language-shell">[root@shell ~]# cat sex.sh#!/bin/bashfor i in `awk '{print $2}' /root/sex.txt`do    declare -A sex    let sex[$i]++donefor a in ${!sex[*]}do    echo "性别:$a 出现了:${sex[$a]}"done#脚本执行结果[root@shell ~]# sh sex.sh |column -t性别:male     出现了:6性别:unknown  出现了:1性别:female   出现了:2</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;shell数组&quot;&gt;&lt;a href=&quot;#shell数组&quot; class=&quot;headerlink&quot; title=&quot;shell数组&quot;&gt;&lt;/a&gt;shell数组&lt;/h1&gt;&lt;h3 id=&quot;01-shell数组的分类&quot;&gt;&lt;a href=&quot;#01-shell数组的分类&quot; class=&quot;headerlink&quot; title=&quot;01. shell数组的分类&quot;&gt;&lt;/a&gt;01. shell数组的分类&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;普通数组：只能以数字作为索引(也称之为下标)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;关联数组：可以使用字符作为索引&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;02-shell数组常用定义方式&quot;&gt;&lt;a href=&quot;#02-shell数组常用定义方式&quot; class=&quot;headerlink&quot; title=&quot;02. shell数组常用定义方式&quot;&gt;&lt;/a&gt;02. shell数组常用定义方式&lt;/h3&gt;&lt;p&gt;定义普通数组&lt;/p&gt;
    
    </summary>
    
    
      <category term="shell" scheme="http://lpcsf.git.io/categories/shell/"/>
    
    
      <category term="shell" scheme="http://lpcsf.git.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>云计算基础</title>
    <link href="http://lpcsf.git.io/2019/10/28/%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    <id>http://lpcsf.git.io/2019/10/28/什么是云计算/</id>
    <published>2019-10-28T13:53:01.352Z</published>
    <updated>2019-10-31T11:30:47.104Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是云计算"><a href="#什么是云计算" class="headerlink" title="什么是云计算"></a>什么是云计算</h3><p>简单的说，云计算是一种按量付费的模式！与计算的底层是通过虚拟化技术来实现的！</p><h3 id="云计算的服务类型"><a href="#云计算的服务类型" class="headerlink" title="云计算的服务类型"></a>云计算的服务类型</h3><p>IAAS 基础设施及服务     虚拟机/ecs/openstack </p><a id="more"></a><p>PAAS 平台及服务           PHP/JAVA/docker容器  </p><p>SAAS 软件及服务            企业邮箱服务/CND服务/RDS数据（开发+运维）</p><h3 id="为什么要用云计算"><a href="#为什么要用云计算" class="headerlink" title="为什么要用云计算"></a>为什么要用云计算</h3><p>提高资源利用率</p><p>大幅减少前期投资</p><p>更加灵活和自动化</p><p>具有更好的安全性</p><h3 id="云计算基础-–-KVM虚拟化"><a href="#云计算基础-–-KVM虚拟化" class="headerlink" title="云计算基础 – KVM虚拟化"></a>云计算基础 – KVM虚拟化</h3><h4 id="什么是虚拟化？"><a href="#什么是虚拟化？" class="headerlink" title="什么是虚拟化？"></a>什么是虚拟化？</h4><p>简单的说，是指通过虚拟化技术将一台计算机虚拟为多台计算机，每台虚拟的计算都可以运行不桶的操作系统，每台虚拟机之间都是完全隔离，互不影响的。</p><h4 id="虚拟化软件的差别"><a href="#虚拟化软件的差别" class="headerlink" title="虚拟化软件的差别"></a>虚拟化软件的差别</h4><p>*<em>qemu *</em>：软件纯模拟，全虚拟化软件。特别慢，AIX，兼容性好</p><p><strong>xen</strong>     ：性能特别好，需要使用专门修改之后的内核，兼容性差！</p><p>*<em>KVM *</em>  ：全虚拟机，有硬件支持CPU，基于内核，而且不需要使用专门的内核</p><h4 id="安装KVM虚拟化管理工具"><a href="#安装KVM虚拟化管理工具" class="headerlink" title="安装KVM虚拟化管理工具"></a>安装KVM虚拟化管理工具</h4><p>环境说明：</p><p>vmware 宿主机 kvm虚拟机</p><p>操作系统：centOS 7.6</p><p>IP规划：10.0.0.11</p><p>内存4G，CPU开启虚拟化</p><p>常规优化：关闭selinux 和firewalld</p><p><img src="E:%5C%E8%80%81%E7%94%B7%E5%AD%A9%E5%AD%A6%E4%B9%A0%5Cmd%E5%9B%BE%E7%89%87%5Cassets%5C1567433525738.png" alt="1567433525738"></p><h4 id="部署KVM"><a href="#部署KVM" class="headerlink" title="部署KVM"></a>部署KVM</h4><p><strong>安装软件</strong></p><pre class=" language-shell"><code class="language-shell">yum install libvirt virt-install qemu-kvm -y# libvirt 作用：虚拟机的管理软件# virt virt-install virt-clone 作用：虚拟机的安装工具和克隆工具#qemu-kvm qemu-img (qcow2,raw)作用：管理虚拟机的虚拟磁盘</code></pre><h5 id="检查kvm是否正常安装-检查kvm是否嵌入内核"><a href="#检查kvm是否正常安装-检查kvm是否嵌入内核" class="headerlink" title="检查kvm是否正常安装(检查kvm是否嵌入内核)"></a>检查kvm是否正常安装(检查kvm是否嵌入内核)</h5><pre class=" language-BASH"><code class="language-BASH">lsmod|grep kvmkvm_intel             183621  0 kvm                   586948  1 kvm_intel#如果没有kvm和kvm_intel，就手动添加一下(2个modprobe命令)，再次检查，正常后启动libvirtd服务</code></pre><h5 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h5><pre class=" language-bash"><code class="language-bash">systemctl start libvirtd.servicesystemctl status libvirtd.service</code></pre><h4 id="安装一台kvm虚拟机"><a href="#安装一台kvm虚拟机" class="headerlink" title="安装一台kvm虚拟机"></a>安装一台kvm虚拟机</h4><h5 id="安装VNC-Viewer"><a href="#安装VNC-Viewer" class="headerlink" title="安装VNC-Viewer"></a>安装VNC-Viewer</h5><p>PC电脑端安装VNC</p><blockquote><p>VNC 远程控制的软件，与操作系统无关，因此可以跨平台使用。</p></blockquote><h5 id="将-CentOS-7-6-上传到-opt-目录下"><a href="#将-CentOS-7-6-上传到-opt-目录下" class="headerlink" title="将 CentOS 7.6 上传到/opt 目录下"></a>将 CentOS 7.6 上传到/opt 目录下</h5><h5 id="开始安装虚拟机操作系统"><a href="#开始安装虚拟机操作系统" class="headerlink" title="开始安装虚拟机操作系统"></a>开始安装虚拟机操作系统</h5><pre class=" language-shell"><code class="language-shell">virt-install --virt-type kvm --os-type=linux --os-variant rhel7 --name centos7 --memory 1024 --vcpus 1 --disk /opt/centos2.raw,format=raw,size=10 --cdrom /opt/CentOS-7-x86_64-DVD-1708.iso --network network=default --graphics vnc,listen=0.0.0.0 --noautoconsole参数说明：--virt-type           虚拟化的类型(Qemu，VMM、Qemu)--os-type=linux      系统类型--os-variant rhel7      系统版本--name               虚拟机的名字--memory 1024         虚拟机的内存--vcpus 1              虚拟cpu的核数--disk                  设置类型与磁盘大小--cdrom             使用的光盘镜像--network             指定网络类型--graphics vnc,listen=0.0.0.0    监视器（模拟显示器）监听地址，我们可以使用桌面vncviewer连接ip:5900即可访问--noautoconsole</code></pre><blockquote><p>云主机都没有swap分区</p><p>为了提高虚拟机性能，不用创建swap分区</p></blockquote><h4 id="kvm-虚拟机的virsh日常管理和配置"><a href="#kvm-虚拟机的virsh日常管理和配置" class="headerlink" title="kvm 虚拟机的virsh日常管理和配置"></a>kvm 虚拟机的virsh日常管理和配置</h4><pre class=" language-shell"><code class="language-shell"># 显示本地活动虚拟机（后面修改查看信息，可使用id号）virsh list            # 列表(只运行或挂载)virsh list --all    # 查看所有虚拟机 Id    Name                           State---------------------------------------------------- 1     centos7                        running# 启动虚拟机virsh start centos7# 显示虚拟机基本信息virsh dominfo centos7# 虚拟机服务（libvirt）启动的时候，就启动虚拟机。相当于开机自启动virsh autostart centos7# 取消虚拟机服务（libvirt）启动的时候，就启动虚拟机virsh autostart --disable centos7# 暂停虚拟机virsh suspend centos7# 启动暂停的虚拟机virsh resume centos7# 正常关闭虚拟机virsh shutdown centos7# 强制关闭虚拟机virsh destroy centos7# 软重启虚拟机,修改了配置需要彻底关闭虚拟机在启动virsh snapshot-list centos-7.6qemu-img snapshot -l centos-7.6.qcow2# 列出虚拟机的所有网口virsh  domiflist centos7# 列出虚拟机所有的块设备virsh domblklist centos7 # 显示虚拟机的当前配置文件，可以使用>重定向到xxx.xml文件，起到备份作用virsh dumpxml centos7# 编辑配置文件(带语法检查)virsh edit centos7# 删除虚拟机，删除之前需要关闭虚拟机virsh undefine centos7</code></pre><h4 id="virsh热添加技术（磁盘、网卡、内存、cpu）常用命令"><a href="#virsh热添加技术（磁盘、网卡、内存、cpu）常用命令" class="headerlink" title="virsh热添加技术（磁盘、网卡、内存、cpu）常用命令"></a>virsh热添加技术（磁盘、网卡、内存、cpu）常用命令</h4><blockquote><p>所有热添加如果需要永久生效都需要在后面加 <code>--config</code></p></blockquote><pre><code># 给</code></pre><h4 id="kvm-虚拟机-快照功能"><a href="#kvm-虚拟机-快照功能" class="headerlink" title="kvm 虚拟机 快照功能"></a>kvm 虚拟机 快照功能</h4><blockquote><p>快照配置文件在/var/lib/libvirt/qemu/snapshot/虚拟机名称/ </p><p> kvm虚拟机默认使用raw格式的镜像格式，性能最好，速度最快，</p><p>它的缺点就是不支持一些新的功能，如支持镜像,zlib磁盘压缩,AES加密等。 </p><p> raw磁盘格式的虚拟机不支持快照功能 , 要使用镜像功能，磁盘格式必须为qcow2 </p></blockquote><pre><code># 查看虚拟机快照virsh snapshot-list centos7 qemu-img snapshot -l centos-7.6.qcow2</code></pre><h1 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h1><pre><code>error: unsupported configuration: internal snapshot for disk vda unsupported for storage type raw# </code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;什么是云计算&quot;&gt;&lt;a href=&quot;#什么是云计算&quot; class=&quot;headerlink&quot; title=&quot;什么是云计算&quot;&gt;&lt;/a&gt;什么是云计算&lt;/h3&gt;&lt;p&gt;简单的说，云计算是一种按量付费的模式！与计算的底层是通过虚拟化技术来实现的！&lt;/p&gt;&lt;h3 id=&quot;云计算的服务类型&quot;&gt;&lt;a href=&quot;#云计算的服务类型&quot; class=&quot;headerlink&quot; title=&quot;云计算的服务类型&quot;&gt;&lt;/a&gt;云计算的服务类型&lt;/h3&gt;&lt;p&gt;IAAS 基础设施及服务     虚拟机/ecs/openstack &lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://lpcsf.git.io/2019/10/28/hello-world/"/>
    <id>http://lpcsf.git.io/2019/10/28/hello-world/</id>
    <published>2019-10-28T13:06:03.954Z</published>
    <updated>2019-10-28T13:06:03.954Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
</feed>
