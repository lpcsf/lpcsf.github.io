<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>GlusterFS</title>
    <url>/2020/02/28/GlusterFS/</url>
    <content><![CDATA[<p>[TOC]</p><h2 id="什么是-GlusterFS"><a href="#什么是-GlusterFS" class="headerlink" title="什么是 GlusterFS"></a>什么是 GlusterFS</h2><h3 id="GlusterFS-概述"><a href="#GlusterFS-概述" class="headerlink" title="GlusterFS 概述"></a>GlusterFS 概述</h3><p>GlusterFS (Gluster File System) 是一个开源的分布式文件系统，主要由 Z RESEARCH 公司负责开发。GlusterFS 是 Scale-Out 存储解决方案 Gluster 的核心，具有强大的横向扩展能力，通过扩展能够支持数PB存储容量和处理数千客户端。GlusterFS 借助 TCP/IP 或 InfiniBand RDMA 网络将物理分布的存储资源聚集在一起，使用单一全局命名空间来管理数据。GlusterFS 基于可堆叠的用户空间设计，可为各种不同的数据负载提供优异的性能。</p><a id="more"></a>

<p><img src="E:%5C%E8%80%81%E7%94%B7%E5%AD%A9%E5%AD%A6%E4%B9%A0%5Cmd%E5%9B%BE%E7%89%87%5Cassets%5Cimage-20200227142148091.png" alt="image-20200227142148091"></p>
<h3 id="GlusterFS-特性"><a href="#GlusterFS-特性" class="headerlink" title="GlusterFS 特性"></a>GlusterFS 特性</h3><ul>
<li><p>扩展性与高性能</p>
<p>Scale-Out架构允许通过简单地增加资源来提高存储容量和性能，磁盘、计算和I/O资源都可以独立增加，支持10GbE和InfiniBand等高速网络互联。Gluster弹性哈希（Elastic Hash）解除了GlusterFS对元数据服务器的需求，消除了单点故障和性能瓶颈，真正实现了并行化数据访问。</p>
</li>
<li><p>高可用性</p>
<p>GlusterFS可以对文件进行自动复制，如镜像或多次复制，从而确保数据总是可以访问，甚至是在硬件故障的情况下也能正常访问。自我修复功能能够把数据恢复到正确的状态，而且修复是以增量的方式在后台执行，几乎不会产生性能负载。GlusterFS没有设计自己的私有数据文件格式，而是采用操作系统中主流标准的磁盘文件系统（如EXT3、ZFS）来存储文件，因此数据可以使用各种标准工具进行复制和访问。</p>
</li>
<li><p>全局统一命名空间</p>
<p>全局统一命名空间将磁盘和内存资源聚集成一个单一的虚拟存储池，对上层用户和应用屏蔽了底层的物理硬件。存储资源可以根据需要在虚拟存储池中进行弹性扩展， 比如扩容或收缩。当存储虚拟机映像时，存储的虚拟映像文件没有数量限制，成千虚拟机均通过单一挂载点进行数据共享。虚拟机I/O可在命名空间内的所有服务器上自动进行负载均衡，消除了SAN环境中经常发生的访问热点和性能瓶颈问题。</p>
</li>
<li><p>弹性哈希算法</p>
<p>GlusterFS采用弹性哈希算法在存储池中定位数据，而不是采用集中式或分布式元数据服务器索引。在其他的Scale-Out存储系统中，元数据服务器通常会导致I/O性能瓶颈和单点故障问题。GlusterFS中，所有在Scale-Out存储配置中的存储系统都可以智能地定位任意数据分片，不需要查看索引或者向其他服务器查询。这种设计机制完全并行化了数据访问，实现了真正的线性性能扩展。</p>
</li>
<li><p>弹性卷管理</p>
<p>数 据储存在逻辑卷中，逻辑卷可以从虚拟化的物理存储池进行独立逻辑划分而得到。存储服务器可以在线进行增加和移除，不会导致应用中断。逻辑卷可以在所有配置 服务器中增长和缩减，可以在不同服务器迁移进行容量均衡，或者增加和移除系统，这些操作都可在线进行。文件系统配置更改也可以实时在线进行并应用，从而可 以适应工作负载条件变化或在线性能调优。</p>
</li>
<li><p>基于标准协议</p>
<p>Gluster存储服务支持NFS, CIFS, HTTP, FTP以及Gluster原生协议，完全与POSIX标准兼容。现有应用程序不需要作任何修改或使用专用API，就可以对Gluster中的数据进行访问。这在公有云环境中部署Gluster时非常有用，Gluster对云服务提供商专用API进行抽象，然后提供标准POSIX接口。</p>
</li>
</ul>
<h3 id="GlusterFS-架构介绍"><a href="#GlusterFS-架构介绍" class="headerlink" title="GlusterFS 架构介绍"></a>GlusterFS 架构介绍</h3><p>它主要由存储服务器（BrickServer）、客户端以及NFS/Samba 存储网关组成。不难发现，<font color="red">GlusterFS 架构中没有元数据服务器组件</font>，这是其最大的设计这点，对于提升整个系统的性能、可靠性和稳定性都有着决定性的意义。GlusterFS 支持TCP/IP 和InfiniBandRDMA 高速网络互联，客户端可通过原生Glusterfs 协议访问数据，其他没有运行GlusterFS客户端的终端可通过NFS/CIFS 标准协议通过存储网关访问数据。</p>
<p><img src="https://s5.51cto.com/wyfs02/M01/84/07/wKiom1eDiHjA-6YjAAW6vXeeVEE704.png" alt="img"></p>
<h3 id="GlusterFS-客户端访问流程"><a href="#GlusterFS-客户端访问流程" class="headerlink" title="GlusterFS  客户端访问流程"></a>GlusterFS  客户端访问流程</h3><p>当客户端访问GlusterFS存储时，首先程序通过访问挂载点的形式读写数据，对于用户和程序而言，集群文件系统是透明的，用户和程序根本感觉不到文件系统是本地还是在远程服务器上。读写操作将会被交给VFS(Virtual File System)来处理，VFS会将请求交给FUSE内核模块，而FUSE又会通过设备/dev/fuse将数据交给GlusterFS Client。最后经过GlusterFS Client的计算，并最终经过网络将请求或数据发送到GlusterFS Server上。</p>
<p><img src="https://img2018.cnblogs.com/blog/1551426/201901/1551426-20190112015721994-73981722.png" alt="img"></p>
<h3 id="GlusterFS-专业术语"><a href="#GlusterFS-专业术语" class="headerlink" title="GlusterFS 专业术语"></a>GlusterFS 专业术语</h3><p><strong>Brick（存储卡）</strong>：存储池中节点对外提供存储服务的目录</p>
<p><strong>Volume （逻辑卷）</strong>：一个逻辑卷是一组 Brick 的集合，卷是数据存储的逻辑设备，类似LVM 中的逻辑卷，大部分 GlusterFS 管理操作都是在逻辑卷上操作的</p>
<p><strong>FUSE（用户空间文件系统）</strong>：是一个内核模块，用户自行创建挂载的文件系统</p>
<p><strong>VFS（接口）</strong>：内核空间对用户控件提供的访问磁盘的接口</p>
<p><strong>Glusterd（后台管理进程）</strong>：在存储集群中的每个节点上都要运行</p>
<h3 id="GlusterFS-集群的模式"><a href="#GlusterFS-集群的模式" class="headerlink" title="GlusterFS 集群的模式"></a>GlusterFS 集群的模式</h3><p>GlusterFS 集群的模式只数据在集群中的存放结构，类似于磁盘阵列中的级别。</p>
<h4 id="分布式卷（Distributed-Volume）"><a href="#分布式卷（Distributed-Volume）" class="headerlink" title="分布式卷（Distributed Volume）"></a>分布式卷（Distributed Volume）</h4><p>GlusterFS的默认卷，在创建卷时，默认选项是创建分布式卷。又称哈希卷，近似于RAID0，文件没有分片，文件根据hash算法写入各个节点的硬盘上，优点是<strong>容量大</strong>，缺点是<strong>没冗余</strong>。</p>
<pre><code># gluster volume create test-volume server1:/exp1 server2:/exp2 server3:/exp3 server4:/exp4</code></pre><p><img src="E:%5C%E8%80%81%E7%94%B7%E5%AD%A9%E5%AD%A6%E4%B9%A0%5Cmd%E5%9B%BE%E7%89%87%5Cassets%5Cac0a300c-ef5f-11e4-8599-e7d06de1165c.png" alt="ac0a300c-ef5f-11e4-8599-e7d06de1165c"></p>
<h4 id="复制卷（Replicated-Volume）"><a href="#复制卷（Replicated-Volume）" class="headerlink" title="复制卷（Replicated Volume）"></a>复制卷（Replicated Volume）</h4><p>相当于RAD1，即同一文件保存一份或多份副本。每个节点上保存相同的内容和目录结构。复制模式因为要保存副本，所以磁盘利用率较低，复制卷时，复制数必须等于卷中Brick所包含的存储服务器数，复制卷<strong>具备冗余性</strong>，即使一个节点损坏，也不影响数据的正常使用；</p>
<p><img src="https://cloud.githubusercontent.com/assets/10970993/7412379/d75272a6-ef5f-11e4-869a-c355e8505747.png" alt="复制卷"></p>
<p>创建方法</p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># gluster volume create test-volume replica 3 transport tcp server1:/exp1 server2:/exp2 </span></code></pre>
<h4 id="分布式复制卷（Distributed-Replicated-Volume）"><a href="#分布式复制卷（Distributed-Replicated-Volume）" class="headerlink" title="分布式复制卷（Distributed Replicated Volume）"></a>分布式复制卷（Distributed Replicated Volume）</h4><p>分布式复制GlusterFS卷结合了分布式和复制Gluster卷的特点，看起来类似RAID10，但其实不同，RAID10其实质是条带化，但分布式复制GlusterFS卷则没有。Brick数必须是副本数的倍数。</p>
<p><img src="https://cloud.githubusercontent.com/assets/10970993/7412402/23a17eae-ef60-11e4-8813-a40a2384c5c2.png" alt="distribution_replicated_volume"></p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># gluster volume create test-volume replica 2 transport tcp server1:/exp1 server2:/exp2 server3:/exp3 </span></code></pre>
<h4 id="条带卷（Striped-Volume）"><a href="#条带卷（Striped-Volume）" class="headerlink" title="条带卷（Striped Volume）"></a>条带卷（Striped Volume）</h4><p>文件是分片均匀写在各个节点的硬盘上的，优点是分布式读写，性能整体较好。缺点是<strong>没有冗余</strong>，分片随机读写可能会导致硬盘IOPS饱和。</p>
<p><strong>注意</strong>：Brick的数量应等于带区卷的带区数。</p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># gluster volume create test-volume stripe 2 transport tcp server1:/exp1 server2:/exp2</span></code></pre>
<p><img src="https://img2018.cnblogs.com/blog/1551426/201901/1551426-20190112020028675-315138583.png" alt="img"></p>
<h4 id="分布式条带卷（Distributed-Striped-Volume）"><a href="#分布式条带卷（Distributed-Striped-Volume）" class="headerlink" title="分布式条带卷（Distributed Striped Volume）"></a>分布式条带卷（Distributed Striped Volume）</h4><p>当单个文件的体型十分巨大，客户端数量更多时，条带卷已经无法满足需求，此时将分布式与条带化结合起来是一个比较好的选择。其性能与服务器数量有关。</p>
<p><strong>注意</strong>：对于分布式条带化卷，块数应为条带数的倍数。</p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># gluster volume create test-volume stripe 4 transport tcp server1:/exp1 server2:/exp2 server3:/exp3 server4:/exp4 server5:/exp5 server6:/exp6 server7:/exp7 server8:/exp8</span></code></pre>
<p><img src="https://cloud.githubusercontent.com/assets/10970993/7412394/0ce267d2-ef60-11e4-9959-43465a2a25f7.png" alt="distribution_striped_volume"></p>
<h4 id="条带复制卷（Striped-Replicated-Volumes）"><a href="#条带复制卷（Striped-Replicated-Volumes）" class="headerlink" title="条带复制卷（Striped Replicated Volumes）"></a>条带复制卷（Striped Replicated Volumes）</h4><p>条带复制卷兼顾了条带卷和复制卷两者的优点，相当于RADI 10，用于存储效率高，备份冗余的场景下。Brick数应为复制计数和条带计数的倍数。</p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># gluster volume create test-volume stripe 2 replica 2 transport tcp server1:/exp1 server2:/exp2 server3:/exp3 server4:/exp4</span></code></pre>
<p><img src="E:%5C%E8%80%81%E7%94%B7%E5%AD%A9%E5%AD%A6%E4%B9%A0%5Cmd%E5%9B%BE%E7%89%87%5Cassets%5C3563ac48-ef60-11e4-823f-ee6100c65ad7.png" alt="3563ac48-ef60-11e4-823f-ee6100c65ad7"></p>
<h4 id="分布式条带复制卷（Distributed-Striped-Replicated-Volumes）"><a href="#分布式条带复制卷（Distributed-Striped-Replicated-Volumes）" class="headerlink" title="分布式条带复制卷（Distributed Striped Replicated Volumes）"></a>分布式条带复制卷（Distributed Striped Replicated Volumes）</h4><p>分布式条带复制卷将分布条带数据在复制卷集群。为了获得最佳效果，可以选择使用分布在高并发的条带复制卷环境下并行访问非常大的文件和性能是至关重要的。对于分布式条带复制卷，Brick数应为条带数和副本数的倍数。</p>
<h2 id="使用-GlusterFS"><a href="#使用-GlusterFS" class="headerlink" title="使用 GlusterFS"></a>使用 GlusterFS</h2><h3 id="部署GlusterFS-集群"><a href="#部署GlusterFS-集群" class="headerlink" title="部署GlusterFS 集群"></a>部署GlusterFS 集群</h3><h4 id="实验环境说明"><a href="#实验环境说明" class="headerlink" title="实验环境说明"></a>实验环境说明</h4><table>
<thead>
<tr>
<th>系统类型</th>
<th>IP地址</th>
<th>主机名</th>
<th>角色</th>
</tr>
</thead>
<tbody><tr>
<td>CentOS 7.6 1810</td>
<td>10.4.7.50</td>
<td>client.onelpc.cn</td>
<td>gluster-client</td>
</tr>
<tr>
<td>CentOS 7.6 1810</td>
<td>10.4.7.51</td>
<td>data1.onelpc.cn</td>
<td>gluster-server</td>
</tr>
<tr>
<td>CentOS 7.6 1810</td>
<td>10.4.7.52</td>
<td>data2.onelpc.cn</td>
<td>gluster-server</td>
</tr>
<tr>
<td>CentOS 7.6 1810</td>
<td>10.4.7.53</td>
<td>data3.onelpc.cn</td>
<td>gluster-server</td>
</tr>
</tbody></table>
<p>client所需软件：glusterfs、glusterfs-fuse</p>
<p>server所需软件：  glusterfs、glusterfs-server、glusterfs-fuse 、glusterfs-rdma  </p>
<p>server端：单独创建一块磁盘用来存储数据</p>
<h4 id="所有节点操作"><a href="#所有节点操作" class="headerlink" title="所有节点操作"></a>所有节点操作</h4><p>关闭防火墙</p>
<pre class=" language-bash"><code class="language-bash">systemctl disable firewalld.service 
systemctl stop firewalld.service</code></pre>
<p>关闭selinux</p>
<pre class=" language-bash"><code class="language-bash"><span class="token function">sed</span> -i <span class="token string">'s/SELINUX=enforcing/SELINUX=disabled/'</span> /etc/selinux/config
setenforce 0</code></pre>
<p>配置域名解析</p>
<pre class=" language-bash"><code class="language-bash"><span class="token function">cat</span> <span class="token operator">&lt;&lt;</span>EOF<span class="token operator">>></span> /etc/hosts
10.4.7.50 client.onelp.cn
10.4.7.51 data1.onelpc.cn
10.4.7.52 data2.onelpc.cn
10.4.7.53 data3.onelpc.cn
EOF</code></pre>
<p>下载Gluster 源</p>
<pre><code>yum -y install centos-release-gluster
// 该源下载软件的站点为国外，速度很慢。建议将地址改为国内。将文件的baseurl地址改为阿里源的地址</code></pre><h4 id="Gluster-Server-节点操作"><a href="#Gluster-Server-节点操作" class="headerlink" title="Gluster-Server 节点操作"></a>Gluster-Server 节点操作</h4><p>安装Server端服务</p>
<pre><code>yum -y install glusterfs glusterfs-server glusterfs-fuse glusterfs-rdma</code></pre><p>初始化数据盘</p>
<blockquote>
<p>，这里为了更真实的模拟生存环境，将数据单独存放在一块磁盘。也可以直接用系统盘进行数据存储。</p>
</blockquote>
<pre class=" language-bash"><code class="language-bash"><span class="token function">fdisk</span> /dev/sdb         //
mkfs.xfs /dev/sdb1 </code></pre>
<p>创建数据存储目录</p>
<pre class=" language-bash"><code class="language-bash"><span class="token function">mkdir</span> -p /gfsdata            //创建数据目录
<span class="token function">mount</span> /dev/sdb1 /gfsdata/    //挂载数据盘到数据目录，设置为开机自启动需要写入到/etc/fstab</code></pre>
<p>启动服务</p>
<pre class=" language-bash"><code class="language-bash">systemctl <span class="token function">enable</span> glusterd        //设置开机自启动
systemctl start glusterd        //启动gluster服务
<span class="token function">netstat</span> -lntup<span class="token operator">|</span><span class="token function">grep</span> gluster        //会启动24007端口</code></pre>
<p>创建 gluster 集群</p>
<pre><code>gluster peer probe data1.onelpc.cn    //添加本机节点
gluster peer probe data2.onelpc.cn    //添加data2节点
gluster peer probe data3.onelpc.cn    //添加data3节点</code></pre><p>查看gluster集群状态</p>
<pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@data1 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># gluster peer status</span>
Number of Peers: 2

Hostname: data2.onelpc.cn
Uuid: ace1a9eb-0edc-4080-b703-e2d018a01d41
State: Peer <span class="token keyword">in</span> Cluster <span class="token punctuation">(</span>Connected<span class="token punctuation">)</span>

Hostname: data3.onelpc.cn
Uuid: 838b4eb8-e1b6-48cc-8b80-db694fd2b815
State: Peer <span class="token keyword">in</span> Cluster <span class="token punctuation">(</span>Connected<span class="token punctuation">)</span></code></pre>
<p>创建数据存储卷(复制卷)</p>
<pre class=" language-bash"><code class="language-bash">gluster  volume  create gv0 replica 3 transport tcp \
data1.onelpc.cn:/gfsdata \
data2.onelpc.cn:/gfsdata \
data3.onelpc.cn:/gfsdata force</code></pre>
<p>启动复制卷</p>
<pre class=" language-bash"><code class="language-bash">gluster volume start gv0

gluster volume info        //查看卷信息
<span class="token operator">==</span><span class="token operator">>></span>输入结果 
Volume Name: gv0
Type: Replicate
Volume ID: 950d0e7e-8d5a-4889-b96e-9fff952e04dd
Status: Started
Snapshot Count: 0
Number of Bricks: 1 x 3 <span class="token operator">=</span> 3
Transport-type: tcp
Bricks:
Brick1: data1.onelpc.cn:/gfsdata    
Brick2: data2.onelpc.cn:/gfsdata
Brick3: data3.onelpc.cn:/gfsdata
Options Reconfigured:
transport.address-family: inet
storage.fips-mode-rchecksum: on
nfs.disable: on
performance.client-io-threads: off</code></pre>
<h4 id="Gluster-Client-节点操作"><a href="#Gluster-Client-节点操作" class="headerlink" title="Gluster-Client 节点操作"></a>Gluster-Client 节点操作</h4><p>安装gluster 客户端服务</p>
<pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@client ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># yum install -y glusterfs gluster-fuse</span></code></pre>
<p>将gluster的gv0卷挂载</p>
<blockquote>
<p>这里直接挂载到/mnt目录</p>
</blockquote>
<pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@client ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># mount -t glusterfs data1.onelpc.cn:gv0 /mnt/</span>

<span class="token punctuation">[</span>root@client ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># df -hT|grep mnt</span>
data1.onelpc.cn:gv0 fuse.glusterfs   20G  238M   20G   2% /mnt</code></pre>
<h4 id="Gluster-服务测试"><a href="#Gluster-服务测试" class="headerlink" title="Gluster 服务测试"></a>Gluster 服务测试</h4><p>Client 节点创建文件</p>
<pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@client ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># touch /mnt/file{1..5}</span>
<span class="token punctuation">[</span>root@client ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># ll /mnt/</span>
total 0
-rw-r--r-- 1 root root 0 Feb 27 18:51 file1
-rw-r--r-- 1 root root 0 Feb 27 18:51 file2
-rw-r--r-- 1 root root 0 Feb 27 18:51 file3
-rw-r--r-- 1 root root 0 Feb 27 18:51 file4
-rw-r--r-- 1 root root 0 Feb 27 18:51 file5</code></pre>
<p>Server节点查看(任意节点)</p>
<p><img src="E:/%E8%80%81%E7%94%B7%E5%AD%A9%E5%AD%A6%E4%B9%A0/md%E5%9B%BE%E7%89%87/assets/image-20200227185640244.png" alt="image-20200227185640244"></p>
<h3 id="管理使用GlusterFS"><a href="#管理使用GlusterFS" class="headerlink" title="管理使用GlusterFS"></a>管理使用GlusterFS</h3><h4 id="Gluster-节点管理"><a href="#Gluster-节点管理" class="headerlink" title="Gluster 节点管理"></a>Gluster 节点管理</h4><p>查看节点信息</p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 查看节点状态</span>
gluster peer status

<span class="token comment" spellcheck="true"># 添加节点 </span>
gluster peer <span class="token operator">&lt;</span>HostaName<span class="token operator">></span> 
gluster peer 10.4.7.100  //可以使用IP或域名

<span class="token comment" spellcheck="true"># 删除节点</span>
gluster peer detach <span class="token operator">&lt;</span>HostName<span class="token operator">></span>
gluster peer detach 10.4.7.100
//移除节点时要保证节点上没有brick，需要提前移除brick</code></pre>
<h4 id="Gluster-卷管理"><a href="#Gluster-卷管理" class="headerlink" title="Gluster 卷管理"></a>Gluster 卷管理</h4><p>基础操作</p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#卷信息</span>
gluster volume info

<span class="token comment" spellcheck="true">#卷状态</span>
gluster volume status

<span class="token comment" spellcheck="true">#启动/停止卷</span>
gluster volume start/stop <span class="token operator">&lt;</span>VOLNAME<span class="token operator">></span>
gluster volume start gv0

<span class="token comment" spellcheck="true">#删除卷</span>
gluster volume delete <span class="token operator">&lt;</span>VOLNAME<span class="token operator">></span>
gluster volume stop gv0        //删除卷之前需要先停止
gluster volume delete gv0 </code></pre>
<p>均衡卷</p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 修复布局，不迁移数据</span>
gluster volume rebalance <span class="token operator">&lt;</span>VOLNAME<span class="token operator">></span> fix-layout start

<span class="token comment" spellcheck="true"># 修复布局，迁移数据</span>
gluster volume rebalance <span class="token operator">&lt;</span>VOLNAME<span class="token operator">></span>  start

<span class="token comment" spellcheck="true"># 强制迁移数据</span>
gluster volume <span class="token operator">&lt;</span>VOLNAME<span class="token operator">></span> rebalance startforce

<span class="token comment" spellcheck="true"># 查看平衡操作后的状态</span>
gluster volume <span class="token operator">&lt;</span>VOLNAME<span class="token operator">></span> rebalance status

<span class="token comment" spellcheck="true"># 停止正在平衡的卷</span>
gluster volume <span class="token operator">&lt;</span>VOLNAME<span class="token operator">></span> rebalance stop</code></pre>
<p>修复卷</p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 只修复有问题的文件</span>
gluster volume heal <span class="token operator">&lt;</span>VOLNAME<span class="token operator">></span>

<span class="token comment" spellcheck="true"># 修复所有文件 </span>
gluster volume heal <span class="token operator">&lt;</span>VOLNAME<span class="token operator">></span> full  

<span class="token comment" spellcheck="true"># 查看自愈详情</span>
gluster volume heal <span class="token operator">&lt;</span>VOLNAME<span class="token operator">></span> info</code></pre>
<h4 id="Brick管理"><a href="#Brick管理" class="headerlink" title="Brick管理"></a>Brick管理</h4><blockquote>
<p>复制卷要一次添加的bricks数是replica的整数倍；stripe同样要求。</p>
<p>复制卷要移除的Brick是replica的整数倍，stripe具有同样的要求，复制卷要移除一对Brick。</p>
</blockquote>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 添加brick </span>
gluster volume add-brick <span class="token operator">&lt;</span>VOLNAME<span class="token operator">></span> <span class="token operator">&lt;</span>NEW-BRICK<span class="token operator">></span>

<span class="token comment" spellcheck="true"># 移除brick</span>
gluster volume remove-brick <span class="token operator">&lt;</span>VOLNAME<span class="token operator">></span> <span class="token operator">&lt;</span>BRICKNAME<span class="token operator">></span> start<span class="token operator">|</span>status<span class="token operator">|</span>commit

<span class="token comment" spellcheck="true"># 在执行移除操作时，数据会移到其他节点。</span>
gluster volume remove-brick gv0 10.4.7.54:/dir 10.4.7.55:/dir 10.4.7.56:/dir start

<span class="token comment" spellcheck="true"># 在执行移除操作后，可以使用status命令进行task状态查看.</span>
gluster volume remove-brick gv0 10.4.7.54:/dir 10.4.7.55:/dir 10.4.7.56:/dir  status

<span class="token comment" spellcheck="true"># 使用commit命令执行brick移除，则不会进行数据迁移而直接删除brick.</span>
gluster volume remove-brick gv0 10.4.7.54:/dir 10.4.7.55:/dir 10.4.7.56:/dir commit

<span class="token comment" spellcheck="true"># 替换brick</span>
注意：仅在分布式复制或纯复制卷中支持在gluster中使用“ replace-brick”命令替换砖块。</code></pre>
<h4 id="系统拓展"><a href="#系统拓展" class="headerlink" title="系统拓展"></a>系统拓展</h4><p>系统配额</p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 开启/关闭系统配额，需要使用enable将其开启；disable为关闭命令</span>
gluster volume <span class="token function">quota</span> <span class="token operator">&lt;</span>VOLNAME<span class="token operator">></span> <span class="token punctuation">{</span>enable/disable<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">#设置目录配额</span>
gluster volume <span class="token function">quota</span> <span class="token operator">&lt;</span>VOLNAME<span class="token operator">></span> limit-usage /directory <span class="token operator">&lt;</span>size<span class="token operator">></span>
gluster volume <span class="token function">quota</span> gv0 limit-usage /quota 1GB        //设置gv0卷下子目录/quota的配额为1G

<span class="token comment" spellcheck="true"># 查看配额</span>
gluster volume <span class="token function">quota</span> <span class="token operator">&lt;</span>VOLNAME<span class="token operator">></span> list
gluster volume <span class="token function">quota</span> gv0 list            //查看gv0卷的配额列表
gluster volume <span class="token function">quota</span> gv0 list /quota    //查看gv0卷下/quota的配额信息</code></pre>
<p>地域复制</p>
<pre><code></code></pre><p>I/O信息查看</p>
<blockquote>
<p><code>profile command</code>提供了一个接口查看每个卷中的每个brick的io信息,有助于确定存储系统中的瓶颈。</p>
</blockquote>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 启动 profiling，之后便可以进行io查看</span>
gluster volume profile VOLNAME start

<span class="token comment" spellcheck="true"># 查看io信息，可以查看到每个brick的io信息</span>
gluster volume profile VOLNAME info

<span class="token comment" spellcheck="true"># 关闭 profiling 功能</span>
gluster volume profile VOLNAME stop</code></pre>
<h4 id="top监控"><a href="#top监控" class="headerlink" title="top监控"></a>top监控</h4><blockquote>
<p><code>top command</code>允许你查看bricks的性能，读取，写入，文件打开调用，文件读取调用，文件写入调用，目录打开调用和目录实际调用。默认100个结果。</p>
</blockquote>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">### BRICK-NAME 指定brick的名称，list-cnt 指定个数</span>
<span class="token comment" spellcheck="true"># 查看打开的fd</span>
gluster volume <span class="token function">top</span> VOLNAME <span class="token function">open</span> <span class="token punctuation">[</span>brick BRICK-NAME<span class="token punctuation">]</span> <span class="token punctuation">[</span>list-cnt cnt<span class="token punctuation">]</span>

<span class="token comment" spellcheck="true"># 查看调用次数最多的读调用</span>
gluster volume <span class="token function">top</span> VOLNAME <span class="token function">read</span> <span class="token punctuation">[</span>brick BRICK-NAME<span class="token punctuation">]</span> <span class="token punctuation">[</span>list-cnt cnt<span class="token punctuation">]</span>

<span class="token comment" spellcheck="true"># 查看调用次数最多的写调用</span>
gluster volume <span class="token function">top</span> VOLNAME <span class="token function">write</span> <span class="token punctuation">[</span>brick BRICK-NAME<span class="token punctuation">]</span> <span class="token punctuation">[</span>list-cnt cnt<span class="token punctuation">]</span>

<span class="token comment" spellcheck="true"># 查看次数最多的目录调用</span>
gluster volume <span class="token function">top</span> opendir <span class="token punctuation">[</span>brick BRICK-NAME<span class="token punctuation">]</span> <span class="token punctuation">[</span>list-cnt cnt<span class="token punctuation">]</span>
gluster volume <span class="token function">top</span> readdir <span class="token punctuation">[</span>brick BRICK-NAME<span class="token punctuation">]</span> <span class="token punctuation">[</span>list-cnt cnt<span class="token punctuation">]</span>

<span class="token comment" spellcheck="true"># 查看每个brick的读性能</span>
gluster volume <span class="token function">top</span> VOLNAME read-perf <span class="token punctuation">[</span>bs blk-size count count<span class="token punctuation">]</span> <span class="token punctuation">[</span>brick BRICK-NAME<span class="token punctuation">]</span> <span class="token punctuation">[</span>list-cnt cnt<span class="token punctuation">]</span>
<span class="token comment" spellcheck="true"># 查看每个brick的写性能</span>
gluster volume <span class="token function">top</span> VOLNAME write-perf <span class="token punctuation">[</span>bs blk-size count count<span class="token punctuation">]</span> <span class="token punctuation">[</span>brick BRICK-NAME<span class="token punctuation">]</span> <span class="token punctuation">[</span>list-cnt cnt<span class="token punctuation">]</span></code></pre>
]]></content>
  </entry>
  <entry>
    <title>git 与 gitlab</title>
    <url>/2020/01/03/git%20%E4%B8%8E%20gitlab/</url>
    <content><![CDATA[<p>[TOC]</p><h2 id="版本控制系统概述-git"><a href="#版本控制系统概述-git" class="headerlink" title="版本控制系统概述 git"></a>版本控制系统概述 git</h2><h3 id="Git基本概述"><a href="#Git基本概述" class="headerlink" title="Git基本概述"></a>Git基本概述</h3><p>Git是一个免费的开源分布式版本控制系统，旨在快速高效地处理从小型到大型项目的所有内容。</p><h3 id="Git安装配置"><a href="#Git安装配置" class="headerlink" title="Git安装配置"></a>Git安装配置</h3><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#安装Git</span>
yum <span class="token function">install</span> -y <span class="token function">git</span>

<span class="token comment" spellcheck="true">#配置用户信息,用户名称和电子邮件地址，每次 Git提交时都会引用这两条信息，说明是谁提交了更新；    </span>
<span class="token function">git</span> config --global user.name <span class="token string">"onelpc"</span>    
<span class="token function">git</span> config --global user.email <span class="token string">"614257760@qq.com"</span>
<span class="token function">git</span> config --global color.ui <span class="token boolean">true</span>  <span class="token comment" spellcheck="true">#配置颜色，非必须</span>

<span class="token comment" spellcheck="true">#会生成一个配置文件</span>
<span class="token punctuation">[</span>root@gitlab ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># cat ~/.gitconfig </span>
<span class="token punctuation">[</span>user<span class="token punctuation">]</span>
    name <span class="token operator">=</span> onelpc
    email <span class="token operator">=</span> 614257760@qq.com
<span class="token punctuation">[</span>color<span class="token punctuation">]</span>
    ui <span class="token operator">=</span> <span class="token boolean">true</span></code></pre><a id="more"></a>


<h3 id="Git基本命令"><a href="#Git基本命令" class="headerlink" title="Git基本命令"></a>Git基本命令</h3><pre class=" language-bash"><code class="language-bash">   add       <span class="token comment" spellcheck="true">#添加文件内容至索引</span>
   bisect     <span class="token comment" spellcheck="true">#通过二分查找定位引入 bug 的变更</span>
   branch    <span class="token comment" spellcheck="true">#列出、创建或删除分支</span>
   checkout  <span class="token comment" spellcheck="true">#检出一个分支或路径到工作区</span>
   clone      <span class="token comment" spellcheck="true">#克隆一个版本库到一个新目录</span>
   commit       <span class="token comment" spellcheck="true">#记录变更到版本库</span>
   <span class="token function">diff</span>       <span class="token comment" spellcheck="true">#显示提交之间、提交和工作区之间等的差异</span>
   fetch       <span class="token comment" spellcheck="true">#从另外一个版本库下载对象和引用</span>
   <span class="token function">grep</span>      <span class="token comment" spellcheck="true">#输出和模式匹配的行</span>
   init      <span class="token comment" spellcheck="true">#创建一个空的 Git 版本库或重新初始化一个已存在的版本库</span>
   log       <span class="token comment" spellcheck="true">#显示提交日志</span>
   merge     <span class="token comment" spellcheck="true">#合并两个或更多开发历史</span>
   <span class="token function">mv</span>           <span class="token comment" spellcheck="true">#移动或重命名一个文件、目录或符号链接</span>
   pull       <span class="token comment" spellcheck="true">#获取并合并另外的版本库或一个本地分支</span>
   push       <span class="token comment" spellcheck="true">#更新远程引用和相关的对象</span>
   rebase    <span class="token comment" spellcheck="true">#本地提交转移至更新后的上游分支中</span>
   reset       <span class="token comment" spellcheck="true">#重置当前HEAD到指定状态</span>
   <span class="token function">rm</span>           <span class="token comment" spellcheck="true">#从工作区和索引中删除文件</span>
   show       <span class="token comment" spellcheck="true">#显示各种类型的对象</span>
   status    <span class="token comment" spellcheck="true">#显示工作区状态</span>
   tag       <span class="token comment" spellcheck="true">#创建、列出、删除或校验一个GPG签名的 tag 对象</span></code></pre>
<h3 id="Git基本操作"><a href="#Git基本操作" class="headerlink" title="Git基本操作"></a>Git基本操作</h3><p>创建git本地仓库</p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#创建本地工作目录</span>
<span class="token function">mkdir</span> /demo
<span class="token function">cd</span> /demo/

<span class="token comment" spellcheck="true">#初始化为git工作目录</span>
<span class="token function">git</span> init </code></pre>
<p>提交数据</p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#提交文件到缓存区，</span>
<span class="token function">git</span> add file1
<span class="token function">git</span> add <span class="token keyword">.</span>   //点<span class="token punctuation">(</span>.<span class="token punctuation">)</span>代表当前目录下所有文件

<span class="token comment" spellcheck="true">#提交文件到本地仓库</span>
<span class="token function">git</span> commit -m <span class="token string">"添加file1"</span>

<span class="token comment" spellcheck="true">#当我们修改了很多文件，而不想每一个都add，想commit自动来提交本地修改(-a参数不会造成新文件被提交，只能修改)</span>
<span class="token function">git</span> commit -a -m <span class="token string">"修改了xxx等x个文件"</span></code></pre>
<p>移动数据</p>
<pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> <span class="token function">mv</span> file1 file4  <span class="token comment" spellcheck="true">#修改文件名称</span>
<span class="token function">git</span> commit -m <span class="token string">'change file name'</span> <span class="token comment" spellcheck="true">#提交</span></code></pre>
<p>对比数据</p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#本地文件与缓冲区文件对比</span>
<span class="token function">git</span> <span class="token function">diff</span> file1

<span class="token comment" spellcheck="true">#缓冲区文件与仓库文件对比</span>
<span class="token function">git</span> <span class="token function">diff</span> --cached file1</code></pre>
<p>撤销修改的文件</p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#提交到缓冲的区文件撤回</span>
<span class="token function">git</span> reset HEAD filename

<span class="token comment" spellcheck="true">#未add到缓冲区的文件撤回</span>
<span class="token function">git</span> checkout filename</code></pre>
<p>查看版本与回退</p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#查看现在版本</span>
<span class="token function">git</span> log --oneline
<span class="token function">git</span> reset --hard 942bdf3

<span class="token comment" spellcheck="true">#查看所有历史版本</span>
<span class="token function">git</span> reflog --oneline
<span class="token function">git</span> reset --hard 942bdf3</code></pre>
<h3 id="Git分支管理"><a href="#Git分支管理" class="headerlink" title="Git分支管理"></a>Git分支管理</h3><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#增加一个新分支</span>
<span class="token function">git</span> branch dev01

<span class="token comment" spellcheck="true">#切换分支</span>
<span class="token function">git</span> checkout  dev01

<span class="token comment" spellcheck="true">#查看当前分支情况/所在分支(*代表当前所在)</span>
<span class="token function">git</span> branch

<span class="token comment" spellcheck="true">#切回主分支</span>
<span class="token function">git</span> checkout  master

<span class="token comment" spellcheck="true">#在主分支合并dev01分支</span>
<span class="token function">git</span> merge dev01  -m <span class="token string">'注释'</span>

<span class="token comment" spellcheck="true">#删除dev01分支</span>
<span class="token function">git</span> branch -d dev01</code></pre>
<h3 id="Git标签管理"><a href="#Git标签管理" class="headerlink" title="Git标签管理"></a>Git标签管理</h3><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#给当前版本打标签</span>
<span class="token function">git</span> tag v1.2 

<span class="token comment" spellcheck="true">#删除标签</span>
<span class="token function">git</span>  tag  -d  v1.2

<span class="token comment" spellcheck="true">#给任意版本打标签</span>
<span class="token function">git</span> tag  -a v1.0  -m  <span class="token string">'优化了1111  修复bug'</span>  a119962 

<span class="token comment" spellcheck="true">#查看代码标签信息,（-n，显示tag信息）</span>
<span class="token function">git</span> tag -n    </code></pre>
<h3 id="Git远程仓库"><a href="#Git远程仓库" class="headerlink" title="Git远程仓库"></a>Git远程仓库</h3><h4 id="将远程仓库与本地仓库关联"><a href="#将远程仓库与本地仓库关联" class="headerlink" title="将远程仓库与本地仓库关联"></a>将远程仓库与本地仓库关联</h4><p>gitee创建一个仓库</p>
<p><img src="https://upload-images.jianshu.io/upload_images/17058164-04d0517e706cbf4e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="创建git仓库"></p>
<p>生成公钥文件</p>
<pre><code>[root@gitlab ~/demo]# ssh-keygen 
[root@gitlab ~/demo]# cat /root/.ssh/id_rsa.pub 
&gt;&gt;将公钥内容复制</code></pre><p>将公钥添加到gitee</p>
<p><img src="https://upload-images.jianshu.io/upload_images/17058164-86c3a9bbce08d7b5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="添加公钥"></p>
<p>按照提示操作</p>
<p><img src="https://upload-images.jianshu.io/upload_images/17058164-33a3276f9c614cf9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="配置仓库"></p>
<h4 id="提交一个文件至远程仓库"><a href="#提交一个文件至远程仓库" class="headerlink" title="提交一个文件至远程仓库"></a>提交一个文件至远程仓库</h4><pre class=" language-css"><code class="language-css">工作区：   touch file<span class="token number">5</span>
暂存区：   git add <span class="token number">.</span>
本地仓库<span class="token punctuation">:</span>  git commit -m <span class="token string">"new file file5"</span>
远程仓库<span class="token punctuation">:</span>  git push origin master     </code></pre>
<h2 id="Gitlab仓库"><a href="#Gitlab仓库" class="headerlink" title="Gitlab仓库"></a>Gitlab仓库</h2><h3 id="Gitlab介绍"><a href="#Gitlab介绍" class="headerlink" title="Gitlab介绍"></a>Gitlab介绍</h3><p>gitlab是一个开源仓库,社区版ce，企业版ee.（基于git基础上开发）</p>
<h3 id="gitlab-部署"><a href="#gitlab-部署" class="headerlink" title="gitlab 部署"></a>gitlab 部署</h3><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#下载gitlab</span>
<span class="token punctuation">[</span>root@gitlab ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># wget https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el7/gitlab-ce-12.3.0-ce.0.el7.x86_64.rpm</span>

<span class="token comment" spellcheck="true">#安装gitlab 依赖</span>
<span class="token punctuation">[</span>root@gitlab ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># yum install -y curl openssh-server openssh-clients postfix cronie policycoreutils-python</span>
<span class="token comment" spellcheck="true">#安装gitlab</span>
<span class="token punctuation">[</span>root@gitlab ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># yum localinstall -y gitlab-ce-12.3.0-ce.0.el7.x86_64.rpm</span>

<span class="token comment" spellcheck="true">#配置gitlab</span>
1.备份gitlab配置文件
<span class="token punctuation">[</span>root@gitlab ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># cp -v /etc/gitlab/{gitlab.rb,gitlab.rb_bak}</span>
<span class="token punctuation">[</span>root@gitlab ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># vim /etc/gitlab/gitlab.rb</span>
2.修改gitlab访问的url 
external_url <span class="token string">'http://gitlab.oldxu.com'</span>
3.关闭一些没有用程序
prometheus<span class="token punctuation">[</span><span class="token string">'enable'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span>
prometheus_monitoring<span class="token punctuation">[</span><span class="token string">'enable'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span>
4.配置邮箱
gitlab_rails<span class="token punctuation">[</span><span class="token string">'gitlab_email_enabled'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span>
gitlab_rails<span class="token punctuation">[</span><span class="token string">'gitlab_email_from'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"614257760@qq.com"</span>  <span class="token comment" spellcheck="true"># 发件邮箱</span>
gitlab_rails<span class="token punctuation">[</span><span class="token string">'gitlab_email_display_name'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'OneLpc'</span> <span class="token comment" spellcheck="true"># 发件人显示名称</span>
gitlab_rails<span class="token punctuation">[</span><span class="token string">'smtp_enable'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span>
gitlab_rails<span class="token punctuation">[</span><span class="token string">'smtp_address'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"smtp.qq.com"</span>
gitlab_rails<span class="token punctuation">[</span><span class="token string">'smtp_port'</span><span class="token punctuation">]</span> <span class="token operator">=</span> 465
gitlab_rails<span class="token punctuation">[</span><span class="token string">'smtp_user_name'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"614257760@qq.com"</span> <span class="token comment" spellcheck="true">#发件人邮箱账户</span>
gitlab_rails<span class="token punctuation">[</span><span class="token string">'smtp_password'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"qweasdzxc"</span>  <span class="token comment" spellcheck="true">#发件人邮箱客户端授权码</span>
gitlab_rails<span class="token punctuation">[</span><span class="token string">'smtp_domain'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"qq.com"</span>
gitlab_rails<span class="token punctuation">[</span><span class="token string">'smtp_authentication'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"login"</span>
gitlab_rails<span class="token punctuation">[</span><span class="token string">'smtp_enable_starttls_auto'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span>
gitlab_rails<span class="token punctuation">[</span><span class="token string">'smtp_tls'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span>

<span class="token comment" spellcheck="true">#初始化gitlab</span>
<span class="token punctuation">[</span>root@gitlab ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># gitlab-ctl reconfigure</span>

<span class="token comment" spellcheck="true">#启动 gitlab</span>
<span class="token punctuation">[</span>root@gitlab ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># gitlab-ctl start</span>

浏览器访问，设置密码</code></pre>
<h3 id="Gitlab汉化"><a href="#Gitlab汉化" class="headerlink" title="Gitlab汉化"></a>Gitlab汉化</h3><blockquote>
<p>汉化包下载地址：<a href="https://gitlab.com/xhang/gitlab" target="_blank" rel="noopener">https://gitlab.com/xhang/gitlab</a></p>
</blockquote>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#停止gitlab</span>
<span class="token punctuation">[</span>root@gitlab ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># gitlab-ctl stop</span>

<span class="token comment" spellcheck="true">#备份原文件</span>
<span class="token punctuation">[</span>root@gitlab ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># \cp -rp /opt/gitlab/embedded/service/gitlab-rails{,.bak_$(date +%F)}</span>

<span class="token comment" spellcheck="true">#替换语言包</span>
<span class="token punctuation">[</span>root@gitlab ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># tar xf gitlab-12-0-stable-zh.tar.gz</span>
<span class="token punctuation">[</span>root@gitlab ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># \cp -r gitlab-12-0-stable-zh/* /opt/gitlab/embedded/service/gitlab-rails/</span>

<span class="token comment" spellcheck="true">#重新加载gitlab</span>
<span class="token punctuation">[</span>root@gitlab ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># gitlab-ctl reconfigure</span>

<span class="token comment" spellcheck="true">#启动gitlab</span>
<span class="token punctuation">[</span>root@gitlab ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># gitlab-ctl start</span>

<span class="token comment" spellcheck="true">#访问gitlab网站设置语句</span>
选择右上角---<span class="token operator">></span>setttings---》Preferences --<span class="token operator">></span>Language</code></pre>
<h3 id="Gitlab备份"><a href="#Gitlab备份" class="headerlink" title="Gitlab备份"></a>Gitlab备份</h3><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#手动备份</span>
<span class="token punctuation">[</span>root@gitlab-ce ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># gitlab-rake gitlab:backup:create</span>
<span class="token operator">>></span>默认的备份目录：<span class="token variable"><span class="token variable">`</span>/var/opt/gitlab/backups<span class="token variable">`</span></span>目录下tar的压缩包


<span class="token comment" spellcheck="true">#修改gitlab备份目录</span>
<span class="token punctuation">[</span>root@gitlab-ce ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># vim /etc/gitlab/gitlab.rb</span>
<span class="token punctuation">..</span>.
gitlab_rails<span class="token punctuation">[</span><span class="token string">'backup_path'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"/data/gitlab/backups"</span>        <span class="token comment" spellcheck="true">#控制备份后的产物放在哪里    </span>
gitlab_rails<span class="token punctuation">[</span><span class="token string">'backup_keep_time'</span><span class="token punctuation">]</span> <span class="token operator">=</span> 604800                   <span class="token comment" spellcheck="true">#保留多久的数据</span>
<span class="token punctuation">..</span>.
<span class="token punctuation">[</span>root@gitlab-ce ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># gitlab-ctl reconfigure</span></code></pre>
<h3 id="Gitlab-数据恢复"><a href="#Gitlab-数据恢复" class="headerlink" title="Gitlab 数据恢复"></a>Gitlab 数据恢复</h3><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 停止相关数据连接服务</span>
<span class="token punctuation">[</span>root@gitlab-ce ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># gitlab-ctl stop unicorn</span>
<span class="token punctuation">[</span>root@gitlab-ce ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># gitlab-ctl stop sidekiq</span>

<span class="token comment" spellcheck="true"># 从1576659867_2019_12_18_12.3.5编号备份中恢复</span>
<span class="token punctuation">[</span>root@gitlab-ce ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># gitlab-rake gitlab:backup:restore BACKUP=1576659867_2019_12_18_12.3.5</span>

<span class="token comment" spellcheck="true"># 启动Gitlab</span>
<span class="token punctuation">[</span>root@gitlab-ce ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># gitlab-ctl start</span></code></pre>
<h3 id="Gitlab迁移"><a href="#Gitlab迁移" class="headerlink" title="Gitlab迁移"></a>Gitlab迁移</h3><p>迁移如同备份与恢复的步骤一样, 只需要将老服务器备份文件拷贝到新服务器上<br>需要注意的是新服务器上的<code>Gitlab</code>的版本必须与创建备份时的<code>Gitlab</code>版本号相同.</p>
<h3 id="Gitlab升级"><a href="#Gitlab升级" class="headerlink" title="Gitlab升级"></a>Gitlab升级</h3><p>关闭 gitlab 服务</p>
<pre><code>[root@gitlab-ce ~]# gitlab-ctl stop unicorn
[root@gitlab-ce ~]# gitlab-ctl stop sidekiq
[root@gitlab-ce ~]# gitlab-ctl stop nginx</code></pre><p>备份gitlab 数据</p>
<pre><code>[root@gitlab-ce ~]# gitlab-rake gitlab:backup:create</code></pre><p>安装新版本的rpm包</p>
<pre class=" language-bash"><code class="language-bash">//直接安装
<span class="token punctuation">[</span>root@gitlab-ce ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># yum install gitlab-ce-12.3.0-ce.0.el7.x86_64.rpm</span>

//报错.
Error executing action <span class="token variable"><span class="token variable">`</span>run<span class="token variable">`</span></span> on resource <span class="token string">'ruby_block[directory resource: /var/opt/gitlab/git-data/repositories]'</span>

//解决方法:
<span class="token punctuation">[</span>root@gitlab-ce ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># chmod 2770 /var/opt/gitlab/git-data/repositories</span></code></pre>
<p>启动gitlab</p>
<pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@gitlab-ce ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># gitlab-ctl reconfigure</span>
<span class="token punctuation">[</span>root@gitlab-ce ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># gitlab-ctl restart</span>
<span class="token punctuation">[</span>root@gitlab-ce ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># head -1 /opt/gitlab/version-manifest.txt</span>
gitlab-ce 12.3.0</code></pre>
<h3 id="Gitlab更改默认Nginx"><a href="#Gitlab更改默认Nginx" class="headerlink" title="Gitlab更改默认Nginx"></a>Gitlab更改默认Nginx</h3><p>略</p>
]]></content>
  </entry>
  <entry>
    <title>云计算之Docker 网络</title>
    <url>/2019/11/10/%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B9%8BDocker%20%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h1 id="Docker-网络"><a href="#Docker-网络" class="headerlink" title="Docker  网络"></a>Docker  网络</h1><h2 id="一、Docker-网络模式"><a href="#一、Docker-网络模式" class="headerlink" title="一、Docker 网络模式"></a>一、Docker 网络模式</h2><ul>
<li><p>host 模式</p>
<p>容器和宿主机共享 network namespace</p>
</li>
<li><p>container 模式</p>
<p>容器和另外一个容器共享 Network namespace</p>
</li>
<li><p>none 模式: </p>
<p>该模式关闭了容器的网络功能</p>
</li>
<li><p>bridge 模式</p>
<p>默认模式，该模式会为每一个容器分配IP，并将容器连接到一个docker 0的虚拟网桥上</p>
</li>
</ul><a id="more"></a>
<h3 id="1-1-bridge-模式"><a href="#1-1-bridge-模式" class="headerlink" title="1.1 bridge 模式"></a>1.1 bridge 模式</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>当Docker进程启动时，会在主机上创建一个名为docker0的虚拟网桥。</p>
<p>此主机上启动<em>Docker容器会连接到这个虚拟网桥上，所以有*</em>默认地址172.17.0.0/16**的地址。</p>
<p>从docker0子网中分配一个IP给容器使用，并设置docker0的IP地址为容器的默认网关。</p>
<p>在主机上创建一对虚拟网卡veth pair设备，Docker将veth pair设备的一端放在新创建的容器中，并命名为eth0（</p>
<p>另一端放在主机中，以vethxxx这样类似的名字命名，并将这个网络设备加入到docker0网桥中。可以通过brctl show命令查看。</p>
<h4 id="bridge-示意图"><a href="#bridge-示意图" class="headerlink" title="bridge 示意图"></a>bridge 示意图</h4><p> <img src="http://tu.bossx.club/blog/20191110/VqOPjwmm379I.png" alt="mark"></p>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@docker01 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># docker run -it --network=bridge busybox</span>
/ <span class="token comment" spellcheck="true"># hostname </span>
5b49bbaecb7e
/ <span class="token comment" spellcheck="true"># ifconfig </span>
eth0      Link encap:Ethernet  HWaddr 02:42:AC:11:00:02  
          inet addr:172.17.0.2  Bcast:172.17.255.255  Mask:255.255.0.0
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:7 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0 
          RX bytes:586 <span class="token punctuation">(</span>586.0 B<span class="token punctuation">)</span>  TX bytes:0 <span class="token punctuation">(</span>0.0 B<span class="token punctuation">)</span>

lo        Link encap:Local Loopback  
          inet addr:127.0.0.1  Mask:255.0.0.0
          UP LOOPBACK RUNNING  MTU:65536  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000 
          RX bytes:0 <span class="token punctuation">(</span>0.0 B<span class="token punctuation">)</span>  TX bytes:0 <span class="token punctuation">(</span>0.0 B<span class="token punctuation">)</span></code></pre>
<h3 id="1-2-host-模式"><a href="#1-2-host-模式" class="headerlink" title="1.2 host 模式"></a>1.2 host 模式</h3><h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><p>使用<code>host</code>网络模式，  容器将不会虚拟出自己的网卡，配置自己的IP等，而是<strong>使用宿主机的IP和端口</strong>。</p>
<p><strong>容器的其他方面，如文件系统、进程列表等还是和宿主机隔离的</strong>。 </p>
<p>host 模式不需要做网络地址转换(NAT)，并且不会为每个端口创建”userlad-proxy”，所以它的<strong>性能是最高</strong>的。</p>
<h4 id="Host-模式示意图"><a href="#Host-模式示意图" class="headerlink" title="Host 模式示意图"></a>Host 模式示意图</h4><p><img src="http://tu.bossx.club/blog/20191110/1Hf7Aecesec0.png" alt="host"></p>
<h4 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h4><blockquote>
<p>公用宿主机，主机名与IP地址都与宿主机公用</p>
</blockquote>
<pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@docker01 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># docker run -it --network=host busybox</span>
/ <span class="token comment" spellcheck="true"># hostname </span>
docker01
/ <span class="token comment" spellcheck="true"># ifconfig eth0</span>
eth0      Link encap:Ethernet  HWaddr 00:0C:29:3A:CC:0A  
          inet addr:10.0.0.11  Bcast:10.0.0.255  Mask:255.255.255.0
          inet6 addr: fe80::20c:29ff:fe3a:cc0a/64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:523747 errors:0 dropped:0 overruns:0 frame:0
          TX packets:147805 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000 
          RX bytes:746408332 <span class="token punctuation">(</span>711.8 MiB<span class="token punctuation">)</span>  TX bytes:18872001 <span class="token punctuation">(</span>17.9 MiB<span class="token punctuation">)</span></code></pre>
<h3 id="1-3-container-模式"><a href="#1-3-container-模式" class="headerlink" title="1.3 container 模式"></a>1.3 container 模式</h3><h4 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h4><p>这个模式指定<strong>新创建的容器和已经存在的一个容器共享一个 Network Namespace</strong>，而不是和宿主机共享。</p>
<p><strong>新创建的容器不会创建自己的网卡，配置自己的 IP，而是和一个指定的容器共享 IP、端口范围</strong>等。</p>
<p>同样，<strong>两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的</strong>。</p>
<p>两个容器的进程可以通过 lo 网卡设备通信。</p>
<h4 id="container-模式示意图"><a href="#container-模式示意图" class="headerlink" title="container 模式示意图"></a>container 模式示意图</h4><p><img src="http://tu.bossx.club/blog/20191110/SkMS4OStxpRT.png" alt="container">)) </p>
<h4 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h4><pre class=" language-shell"><code class="language-shell">[root@docker01 ~]# docker run -it --network container:5b49bbaecb7e  busybox
/ # hostname 
5b49bbaecb7e
/ # ifconfig 
eth0      Link encap:Ethernet  HWaddr 02:42:AC:11:00:02  
          inet addr:172.17.0.2  Bcast:172.17.255.255  Mask:255.255.0.0
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:8 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0 
          RX bytes:656 (656.0 B)  TX bytes:0 (0.0 B)

lo        Link encap:Local Loopback  
          inet addr:127.0.0.1  Mask:255.0.0.0
          UP LOOPBACK RUNNING  MTU:65536  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000 
          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)</code></pre>
<h3 id="1-4-node-模式"><a href="#1-4-node-模式" class="headerlink" title="1.4 node 模式"></a>1.4 node 模式</h3><h4 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h4><p> 使用none模式，Docker容器拥有自己的Network Namespace，但是，<strong>并不为Docker容器进行任何网络配置</strong>。 </p>
<p> 也就是说，这个Docker容器没有网卡、IP、路由等信息，只有lo 网络接口。 </p>
<h4 id="none-示意图"><a href="#none-示意图" class="headerlink" title="none 示意图"></a>none 示意图</h4><p><img src="http://tu.bossx.club/blog/20191110/Xbrhp8dphW8E.png" alt="node">) ) </p>
<h4 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h4><pre class=" language-shell"><code class="language-shell">[root@docker01 ~]# docker run -it --network none busybox
/ # ifconfig 
lo        Link encap:Local Loopback  
          inet addr:127.0.0.1  Mask:255.0.0.0
          UP LOOPBACK RUNNING  MTU:65536  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000 
          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)</code></pre>
<h3 id="1-5-Docker-网络相关命令"><a href="#1-5-Docker-网络相关命令" class="headerlink" title="1.5 Docker 网络相关命令"></a>1.5 Docker 网络相关命令</h3><table>
<thead>
<tr>
<th>docker 命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>docker network connect</td>
<td>将容器连接到网络</td>
</tr>
<tr>
<td>docker network create</td>
<td>创建一个网络</td>
</tr>
<tr>
<td>docker network disconnect</td>
<td>将容器从网络断开</td>
</tr>
<tr>
<td>docker network inspect</td>
<td>查看网络的详细信息</td>
</tr>
<tr>
<td>docker network ls</td>
<td>查看网络列表</td>
</tr>
<tr>
<td>docker network prune</td>
<td>删除所有未使用的网络</td>
</tr>
<tr>
<td>docker network rm</td>
<td>删除网络</td>
</tr>
</tbody></table>
<h2 id="二、Docker-跨主机容器之间的通讯macvlan"><a href="#二、Docker-跨主机容器之间的通讯macvlan" class="headerlink" title="二、Docker 跨主机容器之间的通讯macvlan"></a>二、Docker 跨主机容器之间的通讯macvlan</h2><h3 id="2-1-macvlan-介绍"><a href="#2-1-macvlan-介绍" class="headerlink" title="2.1 macvlan 介绍"></a>2.1 macvlan 介绍</h3><p>macvlan 本身是 linux kernel 模块，其功能是允许在同一个物理网卡上配置多个 MAC 地址，</p>
<p>即多个 interface，每个 interface 可以配置自己的 IP。</p>
<p>macvlan 本质上是一种网卡虚拟化技术</p>
<h3 id="2-2-macvlan网络-创建"><a href="#2-2-macvlan网络-创建" class="headerlink" title="2.2 macvlan网络 创建"></a>2.2 macvlan网络 创建</h3><pre class=" language-shell"><code class="language-shell">[root@docker01 ~]# docker network create --driver macvlan --subnet 10.0.0.0/24 --gateway 10.0.0.254 -o parent=eth0 macvlan_1

参数说明
--driver          使用的网络类型
--subnet          使用的网段/子网范围
--gateway         网段地址
-o parent=eth0  基于eth0进行的桥接/流量将在docker主机上的实际通过的接口
macvlan_1        创建网络的名称    </code></pre>
<p>查看创建网络</p>
<pre class=" language-shell"><code class="language-shell">[root@docker01 ~]# docker network ls
NETWORK ID          NAME                DRIVER              SCOPE
b8aa27b430c9        bridge              bridge              local
418c982a7562        host                host                local
b1627a2e64ff        macvlan_1           macvlan             local   ##创建的macvlan网络
7adeb86e280f        none                null                local</code></pre>
<h3 id="2-3-macvlan网络-测试"><a href="#2-3-macvlan网络-测试" class="headerlink" title="2.3 macvlan网络 测试"></a>2.3 macvlan网络 测试</h3><p><strong>环境说明</strong></p>
<p>​    使用镜像 centos:6.9    </p>
<p>​    docker01 主机：10.0.0.11    </p>
<p>​    docker02 主机：10.0.0.12</p>
<p><strong>1) 开启网卡的混杂模式</strong></p>
<pre class=" language-shell"><code class="language-shell">ip link set eth0 promisc on</code></pre>
<p><strong>2) 创建网络</strong> </p>
<p> docker01 与docker02 同时操作</p>
<pre class=" language-shell"><code class="language-shell">docker network create --driver macvlan --subnet 10.0.0.0/24 --gateway 10.0.0.254 -o parent=eth0 macvlan_1</code></pre>
<p><strong>3) 创建容器</strong></p>
<pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@docker01 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># docker run -it --network macvlan_1  --ip=10.0.0.100 busybox</span>
<span class="token punctuation">[</span>root@docker02 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># docker run -it --network macvlan_1  --ip=10.0.0.200 busybox</span></code></pre>
<p><strong>4) 访问测试</strong></p>
<p>#docker01 主机</p>
<pre class=" language-shell"><code class="language-shell">-- 连接docker02 主机上的容器
/ # ping 10.0.0.200
PING 10.0.0.200 (10.0.0.200): 56 data bytes
64 bytes from 10.0.0.200: seq=0 ttl=64 time=0.324 ms
64 bytes from 10.0.0.200: seq=1 ttl=64 time=0.437 ms

-- 连接 docker02 主机
/ # ping -w 3 10.0.0.11
PING 10.0.0.11 (10.0.0.11): 56 data bytes

--- 10.0.0.11 ping statistics ---
4 packets transmitted, 0 packets received, 100% packet loss

-- 连接docker01 主机
/ # ping  10.0.0.12
PING 10.0.0.12 (10.0.0.12): 56 data bytes
64 bytes from 10.0.0.12: seq=1 ttl=64 time=0.662 ms</code></pre>
<p><strong>5) DHCP 模式</strong></p>
<blockquote>
<p>问题：每个容器都会从<code>1</code>开始分配</p>
</blockquote>
<pre class=" language-shell"><code class="language-shell">[root@docker01 ~]# docker run -it --network macvlan_1 centos:6.9
[root@b0031b3570ba /]# ifconfig 
eth0      Link encap:Ethernet  HWaddr 02:42:0A:00:00:01  
          inet addr:10.0.0.1  Bcast:10.0.0.255  Mask:255.255.255.0
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0 
          RX bytes:0 (0.0 b)  TX bytes:0 (0.0 b)
[root@docker02 ~]# docker run -it --network macvlan_1 centos:6.9 
[root@648805d9dea4 /]# ifconfig 
eth0      Link encap:Ethernet  HWaddr 02:42:0A:00:00:01  
          inet addr:10.0.0.1  Bcast:10.0.0.255  Mask:255.255.255.0
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0 
          RX bytes:0 (0.0 b)  TX bytes:0 (0.0 b)</code></pre>
<h3 id="2-4-macvlan-网络的缺点"><a href="#2-4-macvlan-网络的缺点" class="headerlink" title="2.4 macvlan 网络的缺点"></a>2.4 macvlan 网络的缺点</h3><ul>
<li>需要手动指令IP地址，容易出现IP地址冲突问题</li>
<li>使用macvlan网络的容器无法连接宿主机</li>
</ul>
<h2 id="三、Dcoker跨主机容器通信之overlay"><a href="#三、Dcoker跨主机容器通信之overlay" class="headerlink" title="三、Dcoker跨主机容器通信之overlay"></a>三、Dcoker跨主机容器通信之overlay</h2><h3 id="3-1-overlay-介绍"><a href="#3-1-overlay-介绍" class="headerlink" title="3.1 overlay 介绍"></a>3.1 overlay 介绍</h3><p> overlay模式是多个Docker主机之间的分布式网络解决方案。</p>
<p>该网络位于特定于主机的网络之上，允许连接到它的容器（包括群集服务容器）安全地进行通信。</p>
<p>Docker透明地处理每个数据包与Docker守护程序主机和正确的目标容器之间正确的的路由。 </p>
<p><img src="http://tu.bossx.club/blog/20191109/rJTXbAU6szE9.png?imageslim" alt="overlay"></p>
<h3 id="3-2-overlay-网络使用条件"><a href="#3-2-overlay-网络使用条件" class="headerlink" title="3.2 overlay 网络使用条件"></a>3.2 overlay 网络使用条件</h3><ul>
<li>正常工作的key-value 存储服务，比如 consul、etcd、zookeeper 等</li>
<li>可以访问到 key-value 服务的主机集群</li>
<li>集群中的每台机器的hostname都是唯一的</li>
</ul>
<h3 id="3-3-overlay-网络模拟"><a href="#3-3-overlay-网络模拟" class="headerlink" title="3.3 overlay 网络模拟"></a>3.3 overlay 网络模拟</h3><h4 id="环境说明"><a href="#环境说明" class="headerlink" title="环境说明"></a>环境说明</h4><p><strong>主机</strong></p>
<p>docker-network 10.0.0.10</p>
<p>docker01 10.0.0.11</p>
<p>docker02 10.0.0.12</p>
<p><strong>docker 版本</strong>： Docker version 19.03.4</p>
<h4 id="启动consul"><a href="#启动consul" class="headerlink" title="启动consul"></a>启动consul</h4><blockquote>
<p>这里直接使用最简单的<code>docker</code>方式启动</p>
</blockquote>
<p>创建一个consul 容器</p>
<pre class=" language-shell"><code class="language-shell">[root@consul ~]# docker run -d -p 8500:8500 -h consul --name consul progrium/consul -server -bootstrap
[root@consul ~]# netstat -lntup|grep 8500
tcp6       0      0 :::8500                 :::*                    LISTEN      9628/docker-proxy  </code></pre>
<p>容器创建成功后，会启动一个8500端口</p>
<p>我们通过此端口可以访问consul的web管理界面</p>
<p><img src="http://tu.bossx.club/blog/20191109/DDMr1kYV1yH2.png?imageslim" alt="consul"></p>
<h4 id="修改docker-配置文件"><a href="#修改docker-配置文件" class="headerlink" title="修改docker 配置文件"></a>修改docker 配置文件</h4><blockquote>
<p>–cluster-store 指定 consul 的地址。<br>–cluster-advertise 告知 consul 自己的连接地址。 </p>
</blockquote>
<p>docker01 </p>
<pre class=" language-shell"><code class="language-shell">[root@docker01 ~]# vim /etc/docker/daemon.json
{
  "hosts":["tcp://0.0.0.0:2376","unix:///var/run/docker.sock"],
  "cluster-store": "consul://10.0.0.10:8500",
  "cluster-advertise": "10.0.0.11:2376"
}

[root@docker01 ~]#  vim /usr/lib/systemd/system/docker.service
ExecStart=/usr/bin/dockerd --containerd=/run/containerd/containerd.sock   
[root@docker01 ~]# systemctl daemon-reload 
[root@docker01 ~]# systemctl restart docker</code></pre>
<p>docker02 </p>
<pre class=" language-shell"><code class="language-shell">[root@docker02 ~]# vim /etc/docker/daemon.json
{
  "hosts":["tcp://0.0.0.0:2376","unix:///var/run/docker.sock"],
  "cluster-store": "consul://10.0.0.10:8500",
  "cluster-advertise": "10.0.0.12:2376"
}
[root@docker02 ~]#  vim /usr/lib/systemd/system/docker.service
ExecStart=/usr/bin/dockerd --containerd=/run/containerd/containerd.sock   
[root@docker02 ~]# systemctl daemon-reload 
[root@docker02 ~]# systemctl restart docker</code></pre>
<p>此时 docker01 与docker02 将自动注册到consul 数据库中</p>
<p><img src="http://tu.bossx.club/blog/20191109/FXo0PQfe1GHD.png" alt></p>
<h4 id="创建-overlay-网络"><a href="#创建-overlay-网络" class="headerlink" title="创建 overlay 网络"></a>创建 overlay 网络</h4><p>docker01 </p>
<pre class=" language-shell"><code class="language-shell"> [root@docker01 ~]# docker network create -d overlay --subnet 172.16.2.0/24 --gateway 172.16.2.254  ol1
 [root@docker01 ~]# docker network ls 
NETWORK ID          NAME                DRIVER              SCOPE
7cf8a5332f43        ol1                 overlay             global</code></pre>
<h4 id="测试网络"><a href="#测试网络" class="headerlink" title="测试网络"></a>测试网络</h4><p>创建容器查看网络</p>
<blockquote>
<p>这里需要注意，在overlay网络中，集群中的容器名称必须唯一</p>
</blockquote>
<pre class=" language-shell"><code class="language-shell">[root@docker01 ~]# docker run -it --network ol1 --name test01  busybox:latest
/ # ifconfig 
eth0      Link encap:Ethernet  HWaddr 02:42:AC:10:02:01  
          inet addr:172.16.2.1  Bcast:172.16.2.255  Mask:255.255.255.0
eth1      Link encap:Ethernet  HWaddr 02:42:AC:12:00:02  
          inet addr:172.18.0.2  Bcast:172.18.255.255  Mask:255.255.0.0

[root@docker02 ~]# docker run -it --network ol1 --name test02  busybox:latest
/ # ifconfig 
eth0      Link encap:Ethernet  HWaddr 02:42:AC:10:02:02  
          inet addr:172.16.2.2  Bcast:172.16.2.255  Mask:255.255.255.0
eth1      Link encap:Ethernet  HWaddr 02:42:AC:12:00:02  
          inet addr:172.18.0.2  Bcast:172.18.255.255  Mask:255.255.0.0</code></pre>
<p>连接测试</p>
<pre class=" language-shell"><code class="language-shell">[root@docker02 ~]# docker run -it --network ol1 --name test02  busybox:latest
/ # ping 172.16.2.1
PING 172.16.2.1 (172.16.2.1): 56 data bytes
64 bytes from 172.16.2.1: seq=0 ttl=64 time=0.399 ms
64 bytes from 172.16.2.1: seq=1 ttl=64 time=0.373 ms
/ # ping test01
PING test01 (172.16.2.1): 56 data bytes
64 bytes from 172.16.2.1: seq=0 ttl=64 time=0.317 ms
64 bytes from 172.16.2.1: seq=1 ttl=64 time=0.478 ms
/ # ping 223.5.5.5
PING 223.5.5.5 (223.5.5.5): 56 data bytes
64 bytes from 223.5.5.5: seq=0 ttl=127 time=6.389 ms
64 bytes from 223.5.5.5: seq=1 ttl=127 time=11.280 ms
/ # ping 10.0.0.11
PING 10.0.0.11 (10.0.0.11): 56 data bytes
64 bytes from 10.0.0.11: seq=0 ttl=63 time=0.455 ms
/ # ping 10.0.0.10
PING 10.0.0.10 (10.0.0.10): 56 data bytes
64 bytes from 10.0.0.10: seq=0 ttl=63 time=0.342 ms</code></pre>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>云计算</tag>
        <tag>DOCKER</tag>
      </tags>
  </entry>
  <entry>
    <title>云计算之Docker 基础</title>
    <url>/2019/11/03/%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B9%8BDocker%20%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="云计算之Docker-基础"><a href="#云计算之Docker-基础" class="headerlink" title="云计算之Docker 基础"></a>云计算之Docker 基础</h1><h2 id="1、容器的定义"><a href="#1、容器的定义" class="headerlink" title="1、容器的定义"></a>1、容器的定义</h2><ul>
<li>容器就是在隔离的环境运行的一个进程，如果进程停止，容器就会退出；</li>
<li>隔离的环境拥有自己的系统文件，ip 地址，主机名等；</li>
<li>相比虚拟化，容器更加轻便、快捷高效、快速回滚，共用宿主机内核；</li>
<li>容器是linux内核独有的技术;</li>
<li>目前最常用的容器 Docker（基于 lxc 重构）。</li>
</ul><a id="more"></a>
<h2 id="2、Docker的安装"><a href="#2、Docker的安装" class="headerlink" title="2、Docker的安装"></a>2、Docker的安装</h2><pre class=" language-shell"><code class="language-shell">curl -o /etc/yum.repos.d/docker-ce.repo https://mirrors.ustc.edu.cn/docker-ce/linux/centos/docker-ce.repo
sed -i 's#download.docker.com#mirrors.tuna.tsinghua.edu.cn/docker-ce#g' /etc/yum.repos.d/docker-ce.repo
yum install docker-ce-18.09.9 -y</code></pre>
<h2 id="3、Docker的组成"><a href="#3、Docker的组成" class="headerlink" title="3、Docker的组成"></a>3、Docker的组成</h2><p>Docker是传统的CS架构分为 docker client 和 docker server；</p>
<pre class=" language-shell"><code class="language-shell">[root@master ~]# docker version
Client: Docker Engine - Community
 Version:           19.03.2
 API version:       1.39 (downgraded from 1.40)
 Go version:        go1.12.8
 Git commit:        6a30dfc
 Built:             Thu Aug 29 05:28:55 2019
 OS/Arch:           linux/amd64
 Experimental:      false
Server: Docker Engine - Community
 Engine:
  Version:          18.09.9
  API version:      1.39 (minimum version 1.12)
  Go version:       go1.11.13
  Git commit:       039a7df
  Built:            Wed Sep  4 16:22:32 2019
  OS/Arch:          linux/amd64
  Experimental:     false</code></pre>
<p>Docker主要组件有：镜像、容器、网络、存储、仓库；</p>
<p>Docker是一种软件的打包技术。</p>
<h2 id="4、Docker的使用"><a href="#4、Docker的使用" class="headerlink" title="4、Docker的使用"></a>4、Docker的使用</h2><blockquote>
<p>Docker容器内的第一个进程（初始命令）必须一直处于前台运行的状态（必须夯住），否则这个容器，就会处于退出状态！</p>
</blockquote>
<h3 id="4-1镜像管理"><a href="#4-1镜像管理" class="headerlink" title="4.1镜像管理"></a>4.1镜像管理</h3><p>由于国内网络原因，所以我们需要配置Docker【hub.docker.com】中国官方镜像加速：</p>
<pre class=" language-shell"><code class="language-shell">vi  /etc/docker/daemon.json

{
  "registry-mirrors": ["https://registry.docker-cn.com"]
}</code></pre>
<p><strong>这里我再介绍一种扩展的方法：</strong></p>
<p>在官方镜像源基础上，使用python脚本将需要pull的（k8s.gcr.io、gcr.io、quay.io、docker.io）镜像自动转到国内代理站下载，下面时python脚本，可以放在/usr/local/bin目录下直接调用即可。</p>
<pre class=" language-shell"><code class="language-shell">cat >/usr/local/bin/dockerpull<<eof #! usr bin python # coding="utf8" utf8 without bom import os sys gcr.io xxx yyy:zzz -> gcr.azk8s.cn/xxx/yyy:zzz, for example gcr.io/google_containers/kube-apiserver:v1.14.1
#  k8s.gcr.io/xxx:yyy => gcr.io/google-containers/xxx:yyy -> gcr.azk8s.cn/google-containers/xxx:yyy, for example k8s.gcr.io/kube-apiserver:v1.14.1
#  quay.io/xxx/yyy:zzz -> quay.azk8s.cn/xxx/yyy:zzz, for example quay.io/coreos/flannel:v0.10.0-amd64
converts = [
    {
        'prefix': 'gcr.io',
        'replace': lambda x: x.replace('gcr.io', 'gcr.azk8s.cn'),
    },
    {
        'prefix': 'k8s.gcr.io',
        'replace': lambda x: x.replace('k8s.gcr.io', 'gcr.azk8s.cn/google-containers'),
    },
    {
        'prefix': 'quay.io',
        'replace': lambda x: x.replace('quay.io', 'quay.azk8s.cn'),
    }
]
def execute_sys_cmd(cmd):
    result = os.system(cmd)
    if result != 0:
        print(cmd + " failed.")
        sys.exit(-1)
def usage():
    print("Usage: " + sys.argv[0] + " pull ${image}")
if __name__ == "__main__":
    if len(sys.argv) != 3:
        usage()
        sys.exit(-1)
    image = sys.argv[2]
    imageArray = image.split("/") 
    newImage = '' 
    for cvt in converts:
        if imageArray[0] == cvt['prefix']:
            newImage = cvt['replace'](image)
            break
    if newImage:
        print("-- pull {image} from {newimage} instead --".format(image=image, newimage=newImage))
        cmd = "docker pull {image}".format(image=newImage)
        execute_sys_cmd(cmd)
        cmd = "docker tag {newImage} {image}".format(newImage=newImage, image=image)
        execute_sys_cmd(cmd)
        cmd = "docker rmi {newImage}".format(newImage=newImage)
        execute_sys_cmd(cmd)   
        print("-- pull {image} done --".format(image=image))
        sys.exit(0)
    else:
        cmd = "docker pull {image}".format(image=image)
        execute_sys_cmd(cmd)
        sys.exit(0)
EOF
chmod +x /usr/local/bin/dockerpull
#可以使用如下镜像做下载测试，注意这里版本一定要写正确，如果可以下载则代表镜像站正常：
dockerpull pull k8s.gcr.io/kubernetes-dashboard-amd64:v1.10.1
dockerpull pull gcr.io/jenkinsxio/prow/crier:v20190510-3f2c8d788
dockerpull pull quay.io/coreos/etcd:v3.3
dockerpull pull nginx</eof></code></pre>
<p><strong>常用的Docker镜像管理命令：</strong></p>
<table>
<thead>
<tr>
<th align="left">功能</th>
<th align="left">命令</th>
</tr>
</thead>
<tbody><tr>
<td align="left">拉取镜像</td>
<td align="left">docker pull [镜像名称:版本]</td>
</tr>
<tr>
<td align="left">镜像列表</td>
<td align="left">docker images</td>
</tr>
<tr>
<td align="left">导入镜像</td>
<td align="left">docker load -i [镜像tar包名称]</td>
</tr>
<tr>
<td align="left">导出镜像</td>
<td align="left">docker save -o [镜像tar包名称] [镜像名称:版本]</td>
</tr>
<tr>
<td align="left">dockerfile自动构建镜像</td>
<td align="left">docker build -t [镜像名称:版本] [dockerfile文件目录]</td>
</tr>
<tr>
<td align="left">将容器提交为新镜像</td>
<td align="left">docker commit [容器名称] [新镜像名称:新版本]</td>
</tr>
<tr>
<td align="left">删除镜像</td>
<td align="left">docker rmi [镜像名称:版本]</td>
</tr>
<tr>
<td align="left">镜像操作记录</td>
<td align="left">docker history [镜像名称:版本]</td>
</tr>
<tr>
<td align="left">给镜像设置新的仓库</td>
<td align="left">docker tag [镜像名称:版本] [新镜像名称:新版本]</td>
</tr>
<tr>
<td align="left">查看镜像详细</td>
<td align="left">docker inspect [镜像名称:版本]</td>
</tr>
<tr>
<td align="left">搜索镜像</td>
<td align="left">docker search [关键字]</td>
</tr>
<tr>
<td align="left">仓库登录</td>
<td align="left">docker login</td>
</tr>
<tr>
<td align="left">向仓库推送镜像</td>
<td align="left">docker push [仓库地址/镜像名称:版本]</td>
</tr>
</tbody></table>
<blockquote>
<p>docker tag 指令得到了一个新的，和原来的镜像一模一样的镜像，后续文谈到私仓非常有用。</p>
</blockquote>
<h3 id="4-2容器管理"><a href="#4-2容器管理" class="headerlink" title="4.2容器管理"></a>4.2容器管理</h3><table>
<thead>
<tr>
<th align="left">功能</th>
<th align="left">命令</th>
</tr>
</thead>
<tbody><tr>
<td align="left">启动容器并进入</td>
<td align="left">docker run -it –name [容器名称] [镜像名称:版本] bash</td>
</tr>
<tr>
<td align="left">容器列表</td>
<td align="left">docker ps -a (-l –no-trunc)</td>
</tr>
<tr>
<td align="left">显示 Docker 系统信息，包括镜像和容器数</td>
<td align="left">docker info  【zabbix监控项】</td>
</tr>
<tr>
<td align="left">容器提交为新的镜像</td>
<td align="left">docker commit [容器名称] my_image:v1.0</td>
</tr>
<tr>
<td align="left">容器后台运行</td>
<td align="left">docker run -d –name [容器名称] [镜像名称:版本]</td>
</tr>
<tr>
<td align="left">容器结束后自动删除</td>
<td align="left">docker run –rm –name [容器名称] [镜像名称:版本]</td>
</tr>
<tr>
<td align="left">删除容器</td>
<td align="left">docker rm [容器名称]</td>
</tr>
<tr>
<td align="left">删除所有停止状态的容器</td>
<td align="left">docker container prune</td>
</tr>
<tr>
<td align="left">进入容器 exec 【新终端】</td>
<td align="left">docker exec -it [容器名称] bash</td>
</tr>
<tr>
<td align="left">进入容器 attach</td>
<td align="left">docker attach –sig-proxy=false [容器名称]</td>
</tr>
<tr>
<td align="left">停止容器</td>
<td align="left">docker stop [容器名称]</td>
</tr>
<tr>
<td align="left">Docker 日志</td>
<td align="left">docker logs [容器名称]</td>
</tr>
<tr>
<td align="left">查看容器详细</td>
<td align="left">docker inspect [容器名称]</td>
</tr>
<tr>
<td align="left">查看容器最近一个进程</td>
<td align="left">docker top [容器名称]</td>
</tr>
<tr>
<td align="left">继续运行被停止的容器</td>
<td align="left">docker restart [容器名称]</td>
</tr>
<tr>
<td align="left">暂停一个容器进程</td>
<td align="left">docker pause [容器名称]</td>
</tr>
<tr>
<td align="left">取消暂停</td>
<td align="left">docker unpause [容器名称]</td>
</tr>
<tr>
<td align="left">终止容器</td>
<td align="left">docker kill [容器名称]</td>
</tr>
<tr>
<td align="left">端口映射</td>
<td align="left">docker run -it –name [容器名称] -p 8080:80 [镜像名称:版本] bash</td>
</tr>
<tr>
<td align="left">容器互联【单方向的】</td>
<td align="left">docker run -ti –name [容器名称] –link [被互联容器名称]:[容器内名称] nginx:v1.0 bash</td>
</tr>
<tr>
<td align="left">复制容器文件到宿主</td>
<td align="left">docker cp [容器名称]:[容器内目录] ./</td>
</tr>
<tr>
<td align="left">设置环境变量</td>
<td align="left">docker run -d -e MYSQL_ROOT_PASSWORD=123456 -p 3306:3306 mysql:5.7</td>
</tr>
</tbody></table>
<blockquote>
<p>docker ps -a -q 其中-q静默输出，可以显示所有容器的id，我们可以利用这个做批量启动、删除等操作，如docker rm -f `docker ps -a -q`可以清空所有容器；</p>
</blockquote>
<ul>
<li><code>exec</code>与 <code>attach</code>登陆容器的区别</li>
</ul>
<blockquote>
<p>在 exec 里面执行 exit 命令，你只是关掉了 exec 命令新开的进程，而主进程依旧在运行，所以容器并不会停止；<br>在 attach 里面运行 exit 命令，你实际是终止了主进程，所以容器也就随之被停止了；</p>
</blockquote>
<ul>
<li><code>-p</code> 端口映射配置</li>
</ul>
<blockquote>
<p>指定映射(docker 会自动添加一条iptables规则来实现端口映射)<br>-p hostPort:containerPort<br>-p ip:hostPort:containerPort     指定IP的端口映射<br>-p ip::containerPort(随机端口)<br>-p hostPort:containerPort/udp<br>-p  10.0.0.100::53/udp   使用宿主机的10.0.0.100这个ip地址的随机端口的udp协议映射容器的udp53端口<br>-p 81:80 –p 443:443 可以指定多个-p</p>
</blockquote>
<ul>
<li><code>-e</code>环境变量配置</li>
</ul>
<p>例如MySQL镜像环境变量如下（-e可以有多个）：</p>
<blockquote>
<p>MYSQL_ROOT_PASSWORD=xxx<br>#root用户的密码；<br>MYSQL_DATABASE=xxx<br>#运行时需要创建的数据库名称；<br>MYSQL_USER=xxx<br>#运行时需要创建用户名，与MYSQL_PASSWORD一起使用；<br>MYSQL_PASSWORD=xxx<br>#运行时需要创建的用户名对应的密码，与MYSQL_USER一起使用；<br>MYSQL_ALLOW_EMPTY_PASSWORD=yes #不常用<br>#是否允许root用户的密码为空，该参数对应的值为:yes|no；<br>MYSQL_RANDOM_ROOT_PASSWORD=xxx #不常用<br>#为root用户生成随机密码；<br>MYSQL_ONETIME_PASSWORD=xxx #不常用<br>#设置root用户的密码必须在第一次登陆时修改（只对5.6以上的版本支持）；<br>#MYSQL_ROOT_PASSWORD 和 MYSQL_RANDOM_ROOT_PASSWORD 两者必须有且只有一个。</p>
</blockquote>
<ul>
<li><code>--link</code>容器互联配置</li>
</ul>
<blockquote>
<p>容器间互联，这个参数实质就是在容器的/etc/hosts文件中添加解析，而且只在使用–link参数的可以访问，所以这种网络互联是单向的。</p>
</blockquote>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>云计算</tag>
        <tag>DOCKER</tag>
      </tags>
  </entry>
  <entry>
    <title>OSI 七层模式</title>
    <url>/2019/10/29/OSI%20%E4%B8%83%E5%B1%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<hr><hr><h3 id="OSI-七层模式"><a href="#OSI-七层模式" class="headerlink" title="OSI 七层模式"></a>OSI 七层模式</h3><p><img src="E:%5C%E8%80%81%E7%94%B7%E5%AD%A9%E5%AD%A6%E4%B9%A0%5Cmd%E5%9B%BE%E7%89%87%5Cassets%5Cimage-20191029210227477.png" alt="image-20191029210227477"></p><h3 id="OSI-七层模式详解"><a href="#OSI-七层模式详解" class="headerlink" title="OSI 七层模式详解"></a>OSI 七层模式详解</h3><h5 id="物理层-Physical-Layer"><a href="#物理层-Physical-Layer" class="headerlink" title="物理层/Physical Layer"></a>物理层/Physical Layer</h5><p>物理层规定物理设备，物理线路和设备的触发、维护、关闭物理设备的机械特性</p><p>实际最终的传输也是通过物理层实现的</p><a id="more"></a>




<h5 id="数据链路层-Data-Link-Layer"><a href="#数据链路层-Data-Link-Layer" class="headerlink" title="数据链路层/Data Link Layer"></a>数据链路层/Data Link Layer</h5><p>在物理介质的基础上提供可靠的传输，在这一层利用通信信道实现了无差错的传输</p>
<p>提供了物理寻址(MAC)、数据成帧，数据的检测和重发，流量控制和链路控制等功能</p>
<h5 id="网络层-NetWork-Layer"><a href="#网络层-NetWork-Layer" class="headerlink" title="网络层/ NetWork Layer"></a>网络层/ NetWork Layer</h5><p>将各个子网的数据进行路由选择</p>
<p>将数据从一个主机传送到另一个主机</p>
<p>功能：网际互联  流量控制   行为管理</p>
<p>这一层数据传输 单位为数据包<code>packet</code></p>
<p>协议：IP  ICMP IPX</p>
<h5 id="传输层-Transport-Layer"><a href="#传输层-Transport-Layer" class="headerlink" title="传输层/ Transport Layer"></a>传输层/ Transport Layer</h5><p>传输层把上一层数据进行分段处理，可以提供可靠的传输<code>TPC</code>或不可靠的传输<code>UDP</code></p>
<p>起到了为上层掩盖下层的细节。保证会话层的数据信息能够传送到别一个的会话层</p>
<p>协议：TCP UPD  SPX 等</p>
<h5 id="会话层-Session-Layer"><a href="#会话层-Session-Layer" class="headerlink" title="会话层//Session Layer"></a>会话层//Session Layer</h5><p>负责建立、管理和终止表示层实体之间的通信会话。该层的通信由不同设备中的应用程序之间的服务请求和响应组成。 </p>
<h5 id="表示层-Presentation-Layer"><a href="#表示层-Presentation-Layer" class="headerlink" title="表示层/Presentation Layer"></a>表示层/Presentation Layer</h5><p>对数据的格式进行转换，使得多个主键之间传送的信息能够互相的理解。</p>
<p>数据压缩和加密也是表示层可提供的转换功能之一</p>
<p>协议：ASCII JPEG PNG MPEG 等标准</p>
<h5 id="应用层-Application-Layer"><a href="#应用层-Application-Layer" class="headerlink" title="应用层/Application Layer"></a>应用层/Application Layer</h5><p>作用：计算机用户提供应用接口，也为用户直接提供各种网络服务。</p>
<p>协议：HTTP  HTTPS FTP  POP3 SMTP等</p>
<h3 id="TCP-IP-五层模型"><a href="#TCP-IP-五层模型" class="headerlink" title="TCP/IP 五层模型"></a>TCP/IP 五层模型</h3><blockquote>
<p>TCP/IP五层协议和OSI的七层协议对应关系如下。</p>
</blockquote>
<p><img src="E:%5C%E8%80%81%E7%94%B7%E5%AD%A9%E5%AD%A6%E4%B9%A0%5Cmd%E5%9B%BE%E7%89%87%5Cassets%5Cimage-20191029211715292.png" alt="image-20191029211715292"></p>
<h3 id="OSI-模型-每一层工作的设备"><a href="#OSI-模型-每一层工作的设备" class="headerlink" title="OSI 模型 每一层工作的设备"></a>OSI 模型 每一层工作的设备</h3><p><img src="E:%5C%E8%80%81%E7%94%B7%E5%AD%A9%E5%AD%A6%E4%B9%A0%5Cmd%E5%9B%BE%E7%89%87%5Cassets%5Cimage-20191029211801916.png" alt="image-20191029211801916"></p>
<h3 id="OSI模型-每层主要的协议"><a href="#OSI模型-每层主要的协议" class="headerlink" title="OSI模型 每层主要的协议"></a>OSI模型 每层主要的协议</h3><p><img src="E:%5C%E8%80%81%E7%94%B7%E5%AD%A9%E5%AD%A6%E4%B9%A0%5Cmd%E5%9B%BE%E7%89%87%5Cassets%5Cimage-20191029211831097.png" alt="image-20191029211831097"></p>
]]></content>
  </entry>
  <entry>
    <title>shell - day02</title>
    <url>/2019/10/29/shell%20-%20day02/</url>
    <content><![CDATA[<p>[TOC]</p><h2 id="三、条件测试表达式-非if"><a href="#三、条件测试表达式-非if" class="headerlink" title="三、条件测试表达式 ( 非if)"></a>三、条件测试表达式 ( 非if)</h2><h3 id="1、shell的条件测试"><a href="#1、shell的条件测试" class="headerlink" title="1、shell的条件测试"></a>1、shell的条件测试</h3><blockquote>
<p>是验证条件是否符合预期。以下是常用语法</p>
</blockquote><table>
<thead>
<tr>
<th align="left">条件测试语法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">test &lt;测试表达式&gt;</td>
<td>利用test命令测试条件表达式。</td>
</tr>
<tr>
<td align="left">[ &lt;测试表达式&gt; ]</td>
<td>通过[]测试条件表达式的方法，和test命令的用法相同，**注</td>
</tr>
<tr>
<td align="left">[[ &lt;测试表达式&gt; ]]</td>
<td>通过[[]]测试条件表达式的值的方法，是比test和[]更新的语法格式。</td>
</tr>
<tr>
<td align="left">((测试表达式))</td>
<td>通过<code>(())</code>进行测试条件表达式的方法，一般用于if语句里。</td>
</tr>
</tbody></table><a id="more"></a>


<p> <strong>针对以上表有几个注意事项需要说明：</strong></p>
<ul>
<li><p>在双中括号[[]]中可以使用通配符（如*）等进行模式匹配，这是区别于其他几种语法的地方</p>
</li>
<li><p>&amp;&amp;、||、&gt;、&lt;等操作符可以应用到[[]]中，但不能应用于[]中，在[]中一般用-a、-o、-gt、-lt取代</p>
</li>
<li><p>对于整数的关系运算，也可以使用Shell的算术运算符(())</p>
</li>
</ul>
<h3 id="2、文件测试表达式"><a href="#2、文件测试表达式" class="headerlink" title="2、文件测试表达式"></a>2、文件测试表达式</h3><p>对于文件测试表达式中，常用的文件测试操作符如下所示：</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>[ -f file ]，f的全称为file</td>
<td>文件存在</td>
</tr>
<tr>
<td>[ -e file ]，e的全称为exist</td>
<td>文件(夹)存在</td>
</tr>
<tr>
<td>[ -d dir ]，d的全称为directory</td>
<td>是目录</td>
</tr>
<tr>
<td>[ -L file ]，L的全称为link</td>
<td>是软链接</td>
</tr>
<tr>
<td>[ -s file ]，s的全称为size</td>
<td>文件存在且非空</td>
</tr>
<tr>
<td>[ -S file ]，S的全称为Socket</td>
<td>文件是Socket文件</td>
</tr>
<tr>
<td>[ -r file ]，r的全称为read</td>
<td>文件可读</td>
</tr>
<tr>
<td>[ -w file ]，w的全称为write</td>
<td>文件可写</td>
</tr>
<tr>
<td>[ -x file ]，x的全称为executable</td>
<td>文件可执行</td>
</tr>
</tbody></table>
<h3 id="3、字符串测试表达式"><a href="#3、字符串测试表达式" class="headerlink" title="3、字符串测试表达式"></a>3、字符串测试表达式</h3><blockquote>
<p>比较两个字符是否相同、测试字符串的长度是否为0、字符串是否为NULL等，</p>
</blockquote>
<p> 常用的字符串操作符如下所示：</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>[ “$a” = “$b” ]</td>
<td>测试字符串是否相等。用作赋值时两边不能有空格，用做判断时必须有空格。</td>
</tr>
<tr>
<td>[ “$a” != “$b” ]</td>
<td>测试字符串是否不相等</td>
</tr>
<tr>
<td>[ -n “$str” ]</td>
<td>判断字符串是否非空</td>
</tr>
<tr>
<td>[ -z “$str” ]</td>
<td>判断字符串是否为空</td>
</tr>
<tr>
<td>[ $str ]</td>
<td>判断字符串是否非空，类似于 -n</td>
</tr>
</tbody></table>
<h3 id="4、整数二元比较操作符"><a href="#4、整数二元比较操作符" class="headerlink" title="4、整数二元比较操作符"></a>4、整数二元比较操作符</h3><p>整数二元比较操作符使用参考</p>
<table>
<thead>
<tr>
<th>在[]以及test中使用的比较符号</th>
<th>在(())和[[]]中使用的比较符号</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-eq</td>
<td>==或=</td>
<td>相等的英文equal</td>
</tr>
<tr>
<td>-ne</td>
<td>!=</td>
<td>不相等的英文not equal</td>
</tr>
<tr>
<td>-gt</td>
<td>&gt;</td>
<td>大于的英文greater than</td>
</tr>
<tr>
<td>-ge</td>
<td>&gt;=</td>
<td>大于等于的英文greater equal</td>
</tr>
<tr>
<td>-lt</td>
<td>&lt;</td>
<td>小于的英文less than</td>
</tr>
<tr>
<td>-le</td>
<td>&lt;=</td>
<td>小于等于的英文less equal</td>
</tr>
</tbody></table>
<p><strong>注意：不推荐使用[[]]比较数字，因为在大小比较中，[[]]比较的是字符串的arscII码</strong></p>
<h3 id="5、有关-、-、-用法小结"><a href="#5、有关-、-、-用法小结" class="headerlink" title="5、有关[]、[[]]、(())用法小结"></a>5、有关<code>[]</code>、<code>[[]]</code>、<code>(())</code>用法小结</h3><ul>
<li>整数加双引号比较也可以</li>
<li><code>[[]]</code> 中使用类似 <code>-eq</code> 的写法是正确的，而<code>[[]]</code> 中类似<code>&gt;</code>,<code>&lt;</code>的写法可能不对</li>
<li><code>[[]]</code>中用类似<code>&gt;</code>、<code>&lt;</code>的写法语法没错（经过转义），但是逻辑结果不对，使用<code>=</code>、<code>!=</code>可以正确比较</li>
<li><code>(())</code>中不能使用类似<code>-eq</code>的写法，可以使用类似<code>&gt;</code>、<code>&lt;</code>、<code>==</code>（=不可以）的写法</li>
</ul>
<h2 id="四、if-条件语句"><a href="#四、if-条件语句" class="headerlink" title="四、if 条件语句"></a>四、if 条件语句</h2><blockquote>
<p>if条件语句，简单来说，其语义类似于汉语中的“如果…那么…”。<br>if语句是Linux运维人员在实际生产过程中使用的最频繁也是最重要的语句。  </p>
</blockquote>
<h3 id="4-1-单分支"><a href="#4-1-单分支" class="headerlink" title="4.1 单分支"></a>4.1 单分支</h3><blockquote>
<p>if条件语句的单分支结构主体是“如果…那么…”</p>
</blockquote>
<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a><strong>语法</strong></h4><pre class=" language-shell"><code class="language-shell"># 第一种语法
if <条件表达式>
then
    指令
fi

# 第二种语法
if <条件表达式>;then
    指令
fi</条件表达式></条件表达式></code></pre>
<blockquote>
<p>上文中的“&lt;条件表达式&gt;”位置部分，可以使用test、[]、[[]]、(())等条件表达式</p>
</blockquote>
<h4 id="if-表达式嵌套"><a href="#if-表达式嵌套" class="headerlink" title="if 表达式嵌套"></a>if 表达式嵌套</h4><pre class=" language-shell"><code class="language-shell">if <条件表达式>;then
    if <条件表达式>;then
        指令
    fi
fi</条件表达式></条件表达式></code></pre>
<h4 id="和之前条件表达式的关系"><a href="#和之前条件表达式的关系" class="headerlink" title="和之前条件表达式的关系"></a>和之前条件表达式的关系</h4><p>if条件语句相对于之前讲过的文件表达式[ -f “$file” ] &amp;&amp; echo 1等价于下面的if语句</p>
<pre class=" language-shell"><code class="language-shell">if [ -f “file”]; then
  echo 1
fi</code></pre>
<p>if条件语句的单分支，如果形象的使用中文解释的话，相当于一个女孩这么对你说：</p>
<pre class=" language-shell"><code class="language-shell">如果 <你有房>;那么
    我就嫁给你
果如</你有房></code></pre>
<h3 id="4-2-双分支"><a href="#4-2-双分支" class="headerlink" title="4.2 双分支"></a>4.2 双分支</h3><blockquote>
<p>if条件语句的双分支结构主体则为“如果…那么…否则…”  </p>
</blockquote>
<h4 id="4-2-1-语法"><a href="#4-2-1-语法" class="headerlink" title="4.2.1 语法"></a>4.2.1 语法</h4><pre class=" language-shell"><code class="language-shell">if <条件表达式>;then
    指令集1
else
    指令集2
fi</条件表达式></code></pre>
<h4 id="4-2-2-和之前条件表达式的关系"><a href="#4-2-2-和之前条件表达式的关系" class="headerlink" title="4.2.2 和之前条件表达式的关系"></a>4.2.2 和之前条件表达式的关系</h4><blockquote>
<p>前文的文件测试表达式<code>[ -f “file” ] &amp;&amp; echo 1 || echo 0</code>就相当于下面的双分支的if条件语句</p>
</blockquote>
<pre class=" language-shell"><code class="language-shell">if [ -f “file”]; then
    echo 1
else
    echo 0
fi</code></pre>
<h3 id="4-3-多分支"><a href="#4-3-多分支" class="headerlink" title="4.3 多分支"></a>4.3 多分支</h3><blockquote>
<p>if条件语句多分支结构主体为“如果…，那么…，否则如果…，那么… 否则如果…，那么…，否则</p>
</blockquote>
<h4 id="4-3-1多分支语法"><a href="#4-3-1多分支语法" class="headerlink" title="4.3.1多分支语法"></a>4.3.1多分支语法</h4><pre class=" language-shell"><code class="language-shell">if <条件表达式>;then
    指令集1
elif <条件表达式>;then
    指令集2
else
    指令集3
fi</条件表达式></条件表达式></code></pre>
<h2 id="五、函数"><a href="#五、函数" class="headerlink" title="五、函数"></a>五、函数</h2><blockquote>
<p>简单的说，函数的作用就是将程序里面多次被调用的相同代码组合起来(函数体)，并为其取个名字（函数名）。其他所有想重复调用这部分代码的地方，只需要调用这个名字就好了。</p>
</blockquote>
<h3 id="5-1-shell-函数的优势"><a href="#5-1-shell-函数的优势" class="headerlink" title="5.1 shell 函数的优势"></a>5.1 shell 函数的优势</h3><ul>
<li>把相同的程序段定义成函数，可以减少整个程序的代码量，提高开发效率</li>
<li>增加程序的可读，易读性，提升管理效率</li>
<li>可以实习爱你程序功能模块化，使得程序具备通用型(可移植性)</li>
</ul>
<h3 id="5-2-函数语法"><a href="#5-2-函数语法" class="headerlink" title="5.2 函数语法"></a>5.2 函数语法</h3><h4 id="shell-函数的常见语法格式"><a href="#shell-函数的常见语法格式" class="headerlink" title="shell 函数的常见语法格式"></a>shell 函数的常见语法格式</h4><pre class=" language-shell"><code class="language-shell">function 函数名(){   # 推荐书写函数的方法（带括号）
    指令集...
    return n
}</code></pre>
<h4 id="简化写法-1"><a href="#简化写法-1" class="headerlink" title="简化写法 1"></a>简化写法 1</h4><pre class=" language-SHELL"><code class="language-SHELL">function 函数名 {   # 不推荐使用此方法（无括号，函数名和左花括号之间需要有空格。）
    指令集...
    return n
}</code></pre>
<h4 id="简化写法-2"><a href="#简化写法-2" class="headerlink" title="简化写法 2"></a>简化写法 2</h4><pre class=" language-shell"><code class="language-shell">函数名(){   # 不用function的方法
    指令集...
    return n
}</code></pre>
<h3 id="5-3-函数执行"><a href="#5-3-函数执行" class="headerlink" title="5.3 函数执行"></a>5.3 函数执行</h3><blockquote>
<p>shell 函数分为最基本的函数和可以传参的函数俩种</p>
<p>定义函数的代码段<strong>不会自动执行</strong>，<strong>在调用时执行</strong>；调用即在代码中给定函数并即可； </p>
</blockquote>
<h4 id="不带参数的函数"><a href="#不带参数的函数" class="headerlink" title="不带参数的函数"></a>不带参数的函数</h4><pre class=" language-shell"><code class="language-shell">[root@shell ~]# cat demo1.sh 
#!/bin/bash
# 定义函数
demoFUN(){
    echo " the is shell !!!"
}
#调用函数
demoFUN

#  执行结果
[root@shell ~]# sh demo2.sh 
 the is shell !!!</code></pre>
<h4 id="带参数的函数"><a href="#带参数的函数" class="headerlink" title="带参数的函数"></a>带参数的函数</h4><pre class=" language-shell"><code class="language-shell">[root@shell ~]# cat func1.sh 
#!/bin/bash
function hello(){
    echo "hello $1"
}
hello word！

[root@shell ~]# sh func1.sh 
hello word！</code></pre>
<h2 id="六、case-语句"><a href="#六、case-语句" class="headerlink" title="六、case 语句"></a>六、case 语句</h2><p>  case结构条件句相当于多分支的if/elif/else条件句，但是它比这些条件句看起来更规范公正，常被用于实现系统服务启动脚本等企业应用场景中。</p>
<h3 id="6-1-case-语法"><a href="#6-1-case-语法" class="headerlink" title="6.1 case 语法"></a>6.1 case 语法</h3><pre class=" language-shell"><code class="language-shell">case “变量” in 
值1)
    指令1...
    ;;
值2)
    指令2...
    ;;
*)
    指令3...
esac</code></pre>
<h3 id="6-2-case-语句流程图"><a href="#6-2-case-语句流程图" class="headerlink" title="6.2 case 语句流程图"></a>6.2 case 语句流程图</h3><p><img src="E:%5C%E8%80%81%E7%94%B7%E5%AD%A9%E5%AD%A6%E4%B9%A0%5Cmd%E5%9B%BE%E7%89%87%5Cassets%5Cimage-20191027174808798.png" alt="image-20191027174808798"></p>
<h3 id="6-3-case-实例"><a href="#6-3-case-实例" class="headerlink" title="6.3 case 实例"></a>6.3 case 实例</h3><pre class=" language-shell"><code class="language-shell">[root@shell ~]# cat 1.sh 
echo '输入 1 到 4 之间的数字:'
read -p '你输入的数字为:' aNum
case $aNum in
    1)  echo '你选择了 1'
    ;;
    2)  echo '你选择了 2'
    ;;
    3)  echo '你选择了 3'
    ;;
    4)  echo '你选择了 4'
    ;;
    *)  echo '你没有输入 1 到 4 之间的数字'
    ;;
esac

[root@shell ~]# sh 1.sh 
输入 1 到 4 之间的数字:
你输入的数字为:2
你选择了 2
[root@shell ~]# sh 1.sh 
输入 1 到 4 之间的数字:
你输入的数字为:6
你没有输入 1 到 4 之间的数字</code></pre>
<h2 id="七、while-循环"><a href="#七、while-循环" class="headerlink" title="七、while 循环"></a>七、while 循环</h2><p>while 循环又称之为死循环，常用于重复执行一条指令或一组指令，直到条件不满足停止。</p>
<p>在企业中常用于守护进程或持续运行的程序，也有时候会用while来读取文件的每一行内容。</p>
<p>while循环会对紧跟在while后的条件表达式判断，如果条件成立，就执行while里面的命令或语句，每次执行到done时候就重新判断while表达式是否真的成立，直到表达式不成立才退出。</p>
<h4 id="7-1-while-语法"><a href="#7-1-while-语法" class="headerlink" title="7.1 while 语法"></a>7.1 while 语法</h4><pre class=" language-shell"><code class="language-shell"># 写法1
while <条件表达式>
do
    指令
done

# 写法2
while <条件表达式>;do
    指令
done</条件表达式></条件表达式></code></pre>
<p>while 实例</p>
<pre class=" language-shell"><code class="language-shell">[root@shell ~]# cat 3.sh 
#!/bin/bash
a=1
while [ $a -lt 3 ]
do
  echo $a
  let a=a+1
done

# 执行结果
[root@shell ~]# sh 3.sh 
1
2</code></pre>
<h3 id="7-2-while循环执行的流程图如下所示："><a href="#7-2-while循环执行的流程图如下所示：" class="headerlink" title="7.2 while循环执行的流程图如下所示："></a>7.2 while循环执行的流程图如下所示：</h3><p><img src="E:%5C%E8%80%81%E7%94%B7%E5%AD%A9%E5%AD%A6%E4%B9%A0%5Cmd%E5%9B%BE%E7%89%87%5Cassets%5Cimage-20191027180048283.png" alt="image-20191027180048283"></p>
<h3 id="7-3-while-按行读入文件"><a href="#7-3-while-按行读入文件" class="headerlink" title="7.3 while 按行读入文件"></a>7.3 while 按行读入文件</h3><blockquote>
<p>while可以读取指定的文件，然后可以对每行数据进行自定义处理  </p>
</blockquote>
<ul>
<li><code>&lt;</code> 重定向输入方式(推荐使用的方式)</li>
</ul>
<pre class=" language-sh"><code class="language-sh">while read line
do
    echo $line
done < file</code></pre>
<ul>
<li>cat 方式 </li>
</ul>
<pre class=" language-shell"><code class="language-shell">cat file | while read line
do 
    echo $line
done</code></pre>
<p>while 按行读入 实例</p>
<pre class=" language-shell"><code class="language-shell"># 文件内容
[root@shell ~]# cat one.txt 
1
2
3

# 脚本内容
[root@shell ~]# cat 4.sh 
#!/bin/bash

while read line 
do
  echo $line
done < one.txt

# 执行结果
[root@shell ~]# sh 4.sh 
1
2
3</code></pre>
<h2 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h2><h3 id="for-语法"><a href="#for-语法" class="headerlink" title="for 语法"></a>for 语法</h3><ul>
<li>第一种是 for 为变量取值行</li>
</ul>
<pre class=" language-shell"><code class="language-shell">for 变量名 in 变量取值列表
do
    指令
done</code></pre>
<ul>
<li>第二种称之为C语言型for循环语句</li>
</ul>
<pre class=" language-shell"><code class="language-shell">for((exp1;exp2;exp3))
do
    指令
done</code></pre>
<p>for 语句举例</p>
<pre class=" language-shell"><code class="language-shell">[root@shell ~]# cat for01.sh 
#!/bin/bash
for i in 1 2 3 
do
    echo "the is $i"
done
# 
[root@shell ~]# sh for01.sh 
the is 1
the is 2
the is 3


[root@shell ~]# cat for02.sh 
#!/bin/bash
for (( i=0;i<5;i++ 0 1 )) do echo $i done [root@shell ~]# sh for02.sh 2< code></5;i++></code></pre>
]]></content>
  </entry>
  <entry>
    <title>shell数组的定义</title>
    <url>/2019/10/29/shell%E6%95%B0%E7%BB%84%E7%9A%84%E5%AE%9A%E4%B9%89/</url>
    <content><![CDATA[<h1 id="shell数组"><a href="#shell数组" class="headerlink" title="shell数组"></a>shell数组</h1><h3 id="01-shell数组的分类"><a href="#01-shell数组的分类" class="headerlink" title="01. shell数组的分类"></a>01. shell数组的分类</h3><ul>
<li><strong>普通数组：只能以数字作为索引(也称之为下标)</strong></li>
<li><strong>关联数组：可以使用字符作为索引</strong></li>
</ul><h3 id="02-shell数组常用定义方式"><a href="#02-shell数组常用定义方式" class="headerlink" title="02. shell数组常用定义方式"></a>02. shell数组常用定义方式</h3><p>定义普通数组</p><a id="more"></a>

<pre class=" language-shell"><code class="language-shell">#定义普通数组1：
[root@shell ~]# array=(one two three)
#定义普通数组2:
[root@shell ~]# array=([0]=one [1]=two [2]=three)
#定义普通数组3:
[root@shell ~]# array[0]=one
[root@shell ~]# array[1]=two
[root@shell ~]# array[2]=three

#不连续的索引赋值，双引号将里面的内容当成一个元素
[root@shell ~]# array_1=(oldboy name [5]=linux "centos shell" [10]=kvm)
[root@shell ~]# echo ${array_1[*]}
oldboy name linux centos shell kvm
[root@shell ~]# echo ${!array_1[*]}
0 1 5 6 10</code></pre>
<p>定义管理数组</p>
<blockquote>
<p>创建关联数组前需要声明</p>
</blockquote>
<pre class=" language-shell"><code class="language-shell">#定义关联数组1:
[root@shell ~]# declare -A oldqq
[root@shell ~]# oldqq=([index1]=www [index2]=bbs [index3]=zhihu)

#定义关联数组2:
[root@shell ~]# declare -A oldqq
[root@shell ~]# oldqq[index1]=www 
[root@shell ~]# oldqq[index2]=bbs 
[root@shell ~]# oldqq[index3]=zhihu</code></pre>
<h3 id="03-查看shell数组"><a href="#03-查看shell数组" class="headerlink" title="03. 查看shell数组"></a>03. 查看shell数组</h3><p>查看所有定义的普通数组</p>
<pre class=" language-SHELL"><code class="language-SHELL">[root@shell ~]# declare -a</code></pre>
<p>查看所有定义的关联数组</p>
<pre class=" language-shell"><code class="language-shell">[root@shell ~]# declare -A</code></pre>
<p>查看数组所有元素(*与@都可以)</p>
<pre class=" language-shell"><code class="language-shell">[root@shell ~]# echo ${array[*]}        
one two three
[root@shell ~]# echo ${oldqq[@]}
index1 index2 index3</code></pre>
<p>查看数组所有的索引(下标)</p>
<pre class=" language-SHELL"><code class="language-SHELL">[root@shell ~]# echo ${!array[*]}        
0 1 2
[root@shell ~]# echo ${oldqq[*]}
www bbs zhihu</code></pre>
<p>查看数组的单个元素</p>
<pre class=" language-shell"><code class="language-shell">[root@shell ~]# echo ${array[0]}
one
[root@shell ~]# echo ${array[2]}
three
[root@shell ~]#  echo ${oldqq[index1]}
www
[root@shell ~]#  echo ${oldqq[index3]}
zhihu</code></pre>
<h3 id="04-删除shell数组"><a href="#04-删除shell数组" class="headerlink" title="04. 删除shell数组"></a>04. 删除shell数组</h3><p>删除单个数组元素</p>
<pre class=" language-shell"><code class="language-shell">[root@shell ~]# unset array[3]    #<= 去掉下标为3的数组元素 [root@shell ~]# echo ${array[*]} one two three< code></=></code></pre>
<p>删除整个数组</p>
<pre class=" language-shell"><code class="language-shell">[root@shell ~]# unset array         #<= 删除整个数组 [root@shell ~]# echo ${array[*]} #<="内容为空，说明删除成功" < code></=></code></pre>
<h3 id="05-shell数组内容的截取和替换"><a href="#05-shell数组内容的截取和替换" class="headerlink" title="05. shell数组内容的截取和替换"></a>05. shell数组内容的截取和替换</h3><pre class=" language-shell"><code class="language-shell">[root@shell ~]# array=(a b c d e)    
[root@shell ~]# echo ${!array[*]}
0 1 2 3 4
[root@shell ~]# echo ${array[*]}
a b c d e
[root@shell ~]# echo ${array[*]:1:3}    #<== 1 截取元素1到元素3(默认元素从0开始) b c d [root@shell ~]# array="($(echo" {a..g})) #<="=" 将变量的结果赋值给数组元素 echo ${array[*]} a e f g ${array[*] 1} 把数组中a替换为1，原数组未被真正修改 #数组也是变量，因此也适合变量的字串处理功能 abcdefg) abcabcabc abcdefg ${array[*]#*c} abcabc defg ${array[*]#*b} cabcabc cdefg ${array[*]##*b} ${array[*]%b*} abcabca ${array[*]%%b*} a< code></==></code></pre>
<h3 id="06-shell数组循环打印"><a href="#06-shell数组循环打印" class="headerlink" title="06. shell数组循环打印"></a>06. shell数组循环打印</h3><pre class=" language-shell"><code class="language-shell">#通过C语言类型的for循环
[root@shell scripts]# cat test01sh
#!/bin/bash
ipadd=(
    10.0.0.11
    10.0.0.22
    10.0.0.33
)

for((i=0;i<${#ipadd[*]};i++)) do echo "${ipadd[$i]}" done #通过普通for循环 [root@shell scripts]# cat test02sh #! bin bash ipadd="(" 10.0.0.11 10.0.0.22 10.0.0.33 ) for i in ${ipadd[*]} "$i" #两种打印结果是相同的，这里省略.. sh test01h 10.0.0.33< code></${#ipadd[*]};i++))></code></pre>
<h3 id="07-案例"><a href="#07-案例" class="headerlink" title="07. 案例:"></a>07. 案例:</h3><p> <strong>计算以下数据中性别出现的次数</strong></p>
<pre class=" language-mysql"><code class="language-mysql">[root@shell ~]# cat sex.txt |column -t
zhangsan     male
lisi         female
wangwu       male
lili         male
xx           female
mayun        male
mahuateng    male
wangjianlin  male
cxk          unknown</code></pre>
<p><strong>编写的脚本</strong></p>
<pre class=" language-shell"><code class="language-shell">[root@shell ~]# cat sex.sh
#!/bin/bash
for i in `awk '{print $2}' /root/sex.txt`
do
    declare -A sex
    let sex[$i]++
done

for a in ${!sex[*]}
do
    echo "性别:$a 出现了:${sex[$a]}"
done

#脚本执行结果
[root@shell ~]# sh sex.sh |column -t
性别:male     出现了:6
性别:unknown  出现了:1
性别:female   出现了:2</code></pre>
]]></content>
      <categories>
        <category>shell</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>云计算基础</title>
    <url>/2019/10/28/%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%91%E8%AE%A1%E7%AE%97/</url>
    <content><![CDATA[<h3 id="什么是云计算"><a href="#什么是云计算" class="headerlink" title="什么是云计算"></a>什么是云计算</h3><p>简单的说，云计算是一种按量付费的模式！与计算的底层是通过虚拟化技术来实现的！</p><h3 id="云计算的服务类型"><a href="#云计算的服务类型" class="headerlink" title="云计算的服务类型"></a>云计算的服务类型</h3><p>IAAS 基础设施及服务     虚拟机/ecs/openstack </p><a id="more"></a>

<p>PAAS 平台及服务           PHP/JAVA/docker容器  </p>
<p>SAAS 软件及服务            企业邮箱服务/CND服务/RDS数据（开发+运维）</p>
<h3 id="为什么要用云计算"><a href="#为什么要用云计算" class="headerlink" title="为什么要用云计算"></a>为什么要用云计算</h3><p>提高资源利用率</p>
<p>大幅减少前期投资</p>
<p>更加灵活和自动化</p>
<p>具有更好的安全性</p>
<h3 id="云计算基础-–-KVM虚拟化"><a href="#云计算基础-–-KVM虚拟化" class="headerlink" title="云计算基础 – KVM虚拟化"></a>云计算基础 – KVM虚拟化</h3><h4 id="什么是虚拟化？"><a href="#什么是虚拟化？" class="headerlink" title="什么是虚拟化？"></a>什么是虚拟化？</h4><p>简单的说，是指通过虚拟化技术将一台计算机虚拟为多台计算机，每台虚拟的计算都可以运行不桶的操作系统，每台虚拟机之间都是完全隔离，互不影响的。</p>
<h4 id="虚拟化软件的差别"><a href="#虚拟化软件的差别" class="headerlink" title="虚拟化软件的差别"></a>虚拟化软件的差别</h4><p>*<em>qemu *</em>：软件纯模拟，全虚拟化软件。特别慢，AIX，兼容性好</p>
<p><strong>xen</strong>     ：性能特别好，需要使用专门修改之后的内核，兼容性差！</p>
<p>*<em>KVM *</em>  ：全虚拟机，有硬件支持CPU，基于内核，而且不需要使用专门的内核</p>
<h4 id="安装KVM虚拟化管理工具"><a href="#安装KVM虚拟化管理工具" class="headerlink" title="安装KVM虚拟化管理工具"></a>安装KVM虚拟化管理工具</h4><p>环境说明：</p>
<p>vmware 宿主机 kvm虚拟机</p>
<p>操作系统：centOS 7.6</p>
<p>IP规划：10.0.0.11</p>
<p>内存4G，CPU开启虚拟化</p>
<p>常规优化：关闭selinux 和firewalld</p>
<p><img src="E:%5C%E8%80%81%E7%94%B7%E5%AD%A9%E5%AD%A6%E4%B9%A0%5Cmd%E5%9B%BE%E7%89%87%5Cassets%5C1567433525738.png" alt="1567433525738"></p>
<h4 id="部署KVM"><a href="#部署KVM" class="headerlink" title="部署KVM"></a>部署KVM</h4><p><strong>安装软件</strong></p>
<pre class=" language-shell"><code class="language-shell">yum install libvirt virt-install qemu-kvm -y
# libvirt 作用：虚拟机的管理软件
# virt virt-install virt-clone 作用：虚拟机的安装工具和克隆工具
#qemu-kvm qemu-img (qcow2,raw)作用：管理虚拟机的虚拟磁盘</code></pre>
<h5 id="检查kvm是否正常安装-检查kvm是否嵌入内核"><a href="#检查kvm是否正常安装-检查kvm是否嵌入内核" class="headerlink" title="检查kvm是否正常安装(检查kvm是否嵌入内核)"></a>检查kvm是否正常安装(检查kvm是否嵌入内核)</h5><pre class=" language-BASH"><code class="language-BASH">lsmod|grep kvm
kvm_intel             183621  0 
kvm                   586948  1 kvm_intel
#如果没有kvm和kvm_intel，就手动添加一下(2个modprobe命令)，再次检查，正常后启动libvirtd服务</code></pre>
<h5 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h5><pre class=" language-bash"><code class="language-bash">systemctl start libvirtd.service
systemctl status libvirtd.service</code></pre>
<h4 id="安装一台kvm虚拟机"><a href="#安装一台kvm虚拟机" class="headerlink" title="安装一台kvm虚拟机"></a>安装一台kvm虚拟机</h4><h5 id="安装VNC-Viewer"><a href="#安装VNC-Viewer" class="headerlink" title="安装VNC-Viewer"></a>安装VNC-Viewer</h5><p>PC电脑端安装VNC</p>
<blockquote>
<p>VNC 远程控制的软件，与操作系统无关，因此可以跨平台使用。</p>
</blockquote>
<h5 id="将-CentOS-7-6-上传到-opt-目录下"><a href="#将-CentOS-7-6-上传到-opt-目录下" class="headerlink" title="将 CentOS 7.6 上传到/opt 目录下"></a>将 CentOS 7.6 上传到/opt 目录下</h5><h5 id="开始安装虚拟机操作系统"><a href="#开始安装虚拟机操作系统" class="headerlink" title="开始安装虚拟机操作系统"></a>开始安装虚拟机操作系统</h5><pre class=" language-shell"><code class="language-shell">virt-install --virt-type kvm --os-type=linux --os-variant rhel7 --name centos7 --memory 1024 --vcpus 1 --disk /opt/centos2.raw,format=raw,size=10 --cdrom /opt/CentOS-7-x86_64-DVD-1708.iso --network network=default --graphics vnc,listen=0.0.0.0 --noautoconsole


参数说明：
--virt-type           虚拟化的类型(Qemu，VMM、Qemu)
--os-type=linux      系统类型
--os-variant rhel7      系统版本
--name               虚拟机的名字
--memory 1024         虚拟机的内存
--vcpus 1              虚拟cpu的核数
--disk                  设置类型与磁盘大小
--cdrom             使用的光盘镜像
--network             指定网络类型
--graphics vnc,listen=0.0.0.0    监视器（模拟显示器）监听地址，我们可以使用桌面vncviewer连接ip:5900即可访问
--noautoconsole</code></pre>
<blockquote>
<p>云主机都没有swap分区</p>
<p>为了提高虚拟机性能，不用创建swap分区</p>
</blockquote>
<h4 id="kvm-虚拟机的virsh日常管理和配置"><a href="#kvm-虚拟机的virsh日常管理和配置" class="headerlink" title="kvm 虚拟机的virsh日常管理和配置"></a>kvm 虚拟机的virsh日常管理和配置</h4><pre class=" language-shell"><code class="language-shell"># 显示本地活动虚拟机（后面修改查看信息，可使用id号）
virsh list            # 列表(只运行或挂载)
virsh list --all    # 查看所有虚拟机

 Id    Name                           State
----------------------------------------------------
 1     centos7                        running


# 启动虚拟机
virsh start centos7
# 显示虚拟机基本信息
virsh dominfo centos7
# 虚拟机服务（libvirt）启动的时候，就启动虚拟机。相当于开机自启动
virsh autostart centos7
# 取消虚拟机服务（libvirt）启动的时候，就启动虚拟机
virsh autostart --disable centos7
# 暂停虚拟机
virsh suspend centos7
# 启动暂停的虚拟机
virsh resume centos7
# 正常关闭虚拟机
virsh shutdown centos7
# 强制关闭虚拟机
virsh destroy centos7
# 软重启虚拟机,修改了配置需要彻底关闭虚拟机在启动
virsh snapshot-list centos-7.6
qemu-img snapshot -l centos-7.6.qcow2

# 列出虚拟机的所有网口
virsh  domiflist centos7
# 列出虚拟机所有的块设备
virsh domblklist centos7 

# 显示虚拟机的当前配置文件，可以使用>重定向到xxx.xml文件，起到备份作用
virsh dumpxml centos7

# 编辑配置文件(带语法检查)
virsh edit centos7

# 删除虚拟机，删除之前需要关闭虚拟机
virsh undefine centos7</code></pre>
<h4 id="virsh热添加技术（磁盘、网卡、内存、cpu）常用命令"><a href="#virsh热添加技术（磁盘、网卡、内存、cpu）常用命令" class="headerlink" title="virsh热添加技术（磁盘、网卡、内存、cpu）常用命令"></a>virsh热添加技术（磁盘、网卡、内存、cpu）常用命令</h4><blockquote>
<p>所有热添加如果需要永久生效都需要在后面加 <code>--config</code></p>
</blockquote>
<pre><code># 给</code></pre><h4 id="kvm-虚拟机-快照功能"><a href="#kvm-虚拟机-快照功能" class="headerlink" title="kvm 虚拟机 快照功能"></a>kvm 虚拟机 快照功能</h4><blockquote>
<p>快照配置文件在/var/lib/libvirt/qemu/snapshot/虚拟机名称/ </p>
<p> kvm虚拟机默认使用raw格式的镜像格式，性能最好，速度最快，</p>
<p>它的缺点就是不支持一些新的功能，如支持镜像,zlib磁盘压缩,AES加密等。 </p>
<p> raw磁盘格式的虚拟机不支持快照功能 , 要使用镜像功能，磁盘格式必须为qcow2 </p>
</blockquote>
<pre><code># 查看虚拟机快照
virsh snapshot-list centos7 
qemu-img snapshot -l centos-7.6.qcow2</code></pre><h1 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h1><pre><code>error: unsupported configuration: internal snapshot for disk vda unsupported for storage type raw
# </code></pre>]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/10/28/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
</search>
